<?php

/**
 * @file
 * farmOS crop planning module.
 */

include_once 'farm_crop_plan.features.inc';

/**
 * Implements hook_farm_ui_entities().
 */
function farm_crop_plan_farm_ui_entities() {
  return array(
    'farm_plan' => array(
      'crop' => array(
        'label' => t('Crop Plan'),
        'label_plural' => t('Crop Plans'),
        'view' => 'farm_crop_plan',
      ),
    ),
  );
}

/**
 * Implements hook_farm_plan_record_relationships().
 */
function farm_crop_plan_farm_plan_record_relationships() {
  return array(
    'farm_crop_plan_planting' => array(
      'label' => t('Planting'),
      'entity_type' => 'farm_asset',
      'entity_pk' => 'id',
      'table' => 'farm_crop_plan_planting',
      'field' => 'asset_id',
    ),
    'farm_crop_plan_seeding' => array(
      'label' => t('Seeding'),
      'entity_type' => 'log',
      'entity_pk' => 'id',
      'table' => 'farm_crop_plan_planting',
      'field' => 'seeding_id',
      'required' => FALSE,
    ),
    'farm_crop_plan_transplanting' => array(
      'label' => t('Transplanting'),
      'entity_type' => 'log',
      'entity_pk' => 'id',
      'table' => 'farm_crop_plan_planting',
      'field' => 'transplanting_id',
      'required' => FALSE,
    ),
  );
}

/**
 * Implements hook_menu().
 */
function farm_crop_plan_menu() {
  $items['farm/plan/%farm_plan/plantings'] = array(
    'title' => 'Plantings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('farm_crop_plan_planting_form', 2),
    'access callback' => 'farm_crop_plan_access',
    'access arguments' => array(2),
    'type' => MENU_LOCAL_TASK,
    'weight' => 20,
  );
  return $items;
}

/**
 * Access callback for crop plan tabs.
 */
function farm_crop_plan_access($plan) {

  // If the plan is not a crop plan, deny access.
  if ($plan->type != 'crop') {
    return FALSE;
  }

  // Defer to the farm plan access callback.
  return farm_plan_access('update', $plan);
}

/**
 * Implements hook_theme().
 */
function farm_crop_plan_theme($existing, $type, $theme, $path) {
  return array(
    'farm_crop_plan_areas' => array(
      'variables' => array(
        'plan_id' => NULL,
      ),
      'file' => 'farm_crop_plan.theme.inc',
    ),
    'farm_crop_plan_plantings' => array(
      'variables' => array(
        'plan_id' => NULL,
      ),
      'file' => 'farm_crop_plan.theme.inc',
    ),
  );
}

/**
 * Implements hook_entity_view().
 */
function farm_crop_plan_entity_view($entity, $type, $view_mode, $langcode) {

  // Only proceed if this is the full view mode of a crop plan.
  if (!($type == 'farm_plan' && $entity->type == 'crop' && $view_mode == 'full')) {
    return;
  }

  // Reference the entity content object.
  $content = &$entity->content;

  // Add the crop plan form.
  $content['form'] = drupal_get_form('farm_crop_plan_form', $entity);
  $content['form']['#weight'] = 100;
}

/**
 * Crop plan form.
 */
function farm_crop_plan_form($form, &$form_state, $plan) {
  $form = array();

  // Add an options fieldset.
  $form['options'] = array(
    '#type' => 'fieldset',
    '#title' => t('Options'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  // Toggle the timeline view by planting (default) or by area.
  $form['options']['mode'] = array(
    '#type' => 'radios',
    '#title' => t('Organize timeline'),
    '#options' => array(
      'planting' => t('by planting'),
      'area' => t('by area'),
    ),
    '#default_value' => 'planting',
    '#ajax' => array(
      'callback' => 'farm_crop_plan_form_timeline_ajax',
      'wrapper' => 'crop-plan-timeline',
    ),
  );

  // Crop plan timeline visualization.
  $theme = 'farm_crop_plan_plantings';
  if (isset($form_state['values']['mode']) && $form_state['values']['mode'] == 'area') {
    $theme = 'farm_crop_plan_areas';
  }
  $form['timeline'] = array(
    '#markup' => theme($theme, array('plan_id' => $plan->id)),
    '#prefix' => '<div id="crop-plan-timeline">',
    '#suffix' => '</div>',
  );

  return $form;
}

/**
 * Crop plan form mode ajax callback.
 */
function farm_crop_plan_form_timeline_ajax($form, $form_state) {
  return $form['timeline'];
}

/**
 * Planting form.
 */
function farm_crop_plan_planting_form($form, &$form_state, $plan) {
  $form['#tree'] = TRUE;

  // Store the plan entity for use in submit.
  $form['plan'] = array(
    '#type' => 'value',
    '#value' => $plan,
  );

  // Add Planting fieldset.
  $form['new'] = farm_crop_plan_planting_details_form($plan);
  $form['new']['#type'] = 'fieldset';
  $form['new']['#title'] = t('Add a planting');
  $form['new']['#collapsible'] = TRUE;
  $form['new']['#collapsed'] = TRUE;

  // Display Plantings associated with this plan.
  // Load plantings associated with this plan.
  $planting_ids = farm_plan_linked_records('farm_crop_plan_planting', $plan->id);
  $plantings = farm_asset_load_multiple($planting_ids);

  // Sort plantings by name.
  usort($plantings, function($a, $b) { return strcmp($a->name, $b->name);});

  // Iterate through the plantings and build forms.
  foreach ($plantings as $planting) {

    // Add a planting details form.
    $planting_form = farm_crop_plan_planting_details_form($plan, $planting);

    // Make it a fieldset with a title.
    $planting_form['#type'] = 'fieldset';
    $planting_form['#collapsible'] = TRUE;
    $planting_form['#collapsed'] = TRUE;
    $planting_form['#title'] = entity_label('farm_asset', $planting);

    // Add the planting to the form values, for use in form submission.
    $planting_form['planting'] = array(
      '#type' => 'value',
      '#value' => $planting,
    );

    // If the planting has an ID, add a link to remove it.
    if (!empty($planting->id)) {
      $planting_form['remove'] = array(
        '#type' => 'markup',
        '#markup' => l(t('Remove'), 'farm/plan/' . $plan->id . '/farm_crop_plan_planting/' . $planting->id . '/delete', array('query' => array('destination' => current_path()))),
        '#weight' => 100,
      );
    }

    $form['plantings'][$planting->id] = $planting_form;
  }

  // Submit button for saving all changes.
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save Plantings'),
    '#weight' => 100,
  );

  // Add JS behavior to autocheck log status checkboxes.
  drupal_add_js(drupal_get_path('module', 'farm_crop_plan') . '/js/farm_crop_plan_log_status.js');

  return $form;
}

/**
 * Planting details sub-form.
 */
function farm_crop_plan_planting_details_form($plan, $planting = NULL) {
  $form = array();

  // If a plan ID is not available, bail.
  if (empty($plan->id)) {
    return $form;
  }

  // Define the date format for logs.
  $date_format = 'Y-m-d';

  // Define form defaults.
  $defaults = array(
    'name' => NULL,
    'crop' => NULL,
    'seeding' => array(
      'done' => FALSE,
      'date' => NULL,
      'location' => '',
      'quantity' => array(
        'measure' => 'count',
        'value' => NULL,
        'units' => NULL,
      ),
    ),
    'transplanting' => array(
      'done' => FALSE,
      'days_to_transplant' => '',
      'date' => NULL,
      'location' => '',
      'quantity' => array(
        'measure' => 'count',
        'value' => NULL,
        'units' => NULL,
      ),
    ),
    'days_to_harvest' => '',
    'harvest_window' => '',
  );

  // Load values from the planting and logs to override the defaults.
  if (!empty($planting)) {

    // Get the planting metadata wrapper.
    $planting_wrapper = entity_metadata_wrapper('farm_asset', $planting);

    // Get the planting name.
    $defaults['name'] = $planting->name;

    // Get the crop name.
    $defaults['crop'] = $planting_wrapper->field_farm_crop->label();

    // Load information from the {farm_crop_plan_planting} table.
    $farm_crop_plan_planting = db_query('SELECT * FROM {farm_crop_plan_planting} WHERE plan_id = :plan_id AND asset_id = :asset_id', array(':plan_id' => $plan->id, ':asset_id' => $planting->id))->fetchAssoc();

    // Get the days to transplant.
    $defaults['transplanting']['days_to_transplant'] = $farm_crop_plan_planting['days_to_transplant'];

    // Get the days to harvest.
    $defaults['days_to_harvest'] = $farm_crop_plan_planting['days_to_harvest'];

    // Get the harvest window.
    $defaults['harvest_window'] = $farm_crop_plan_planting['harvest_window'];

    // Define log types to create on planting assets.
    $log_types = array(
      'transplanting' => 'farm_transplanting',
      'seeding' => 'farm_seeding'
    );

    // Iterate through the log types.
    foreach($log_types as $label => $type) {

      // Save the field name to lookup based on the log type.
      $field_name = $label . '_id';

      // Find logs that reference the planting.
      $query = db_select('farm_crop_plan_planting', 'p');
      $query->addField('p', $field_name);
      $query->condition('plan_id', $plan->id);
      $query->condition('asset_id', $planting->id);
      $result = $query->execute();
      foreach ($result as $row) {

        // Check if the log is included in the plan.
        if (!empty($row->{$field_name})) {

          // Load the log.
          $log = log_load($row->{$field_name});

          // Save the log for later.
          $defaults[$label]['log'] = $log;

          // Update default log status.
          $defaults[$label]['done'] = $log->done;

          // Update default form values associated with the log type.
          $defaults[$label]['date'] = $log->timestamp;

          // Load areas referenced by the log.
          $areas = array();
          if (!empty($log->field_farm_movement[LANGUAGE_NONE][0]['value'])) {
            $movement = field_collection_item_load($log->field_farm_movement[LANGUAGE_NONE][0]['value']);
            if (!empty($movement->field_farm_move_to[LANGUAGE_NONE])) {
              foreach ($movement->field_farm_move_to[LANGUAGE_NONE] as $area_ref) {

                // If the term ID is empty, skip it.
                if (empty($area_ref['tid'])) {
                  continue;
                }
                $area_id = $area_ref['tid'];

                // Load the area. If it can't be loaded, skip it.
                $area = taxonomy_term_load($area_id);
                if (empty($area)) {
                  continue;
                }

                // Add to the list of area options.
                $areas[] = entity_label('taxonomy_term', $area);
              }
            }
          }

          // Assemble the location name as a comma-separated list.
          $defaults[$label]['location'] = implode(', ', $areas);

          // Load quantity data from log.
          $data = farm_quantity_log_data($log);
          if (!empty($data[0]['value'])) {
            $quantity = $data[0];
            $defaults[$label]['quantity']['measure'] = $quantity['measure'];
            $defaults[$label]['quantity']['value'] = $quantity['value'];
            $defaults[$label]['quantity']['units'] = $quantity['units'];
          }
        }
      }
    }
  }

  // Crop.
  $form['crop'] = array(
    '#type' => 'textfield',
    '#title' => t('Crop/variety'),
    '#autocomplete_path' => 'taxonomy/autocomplete/field_farm_crop',
    '#default_value' => $defaults['crop'],
    '#weight' => 1,
  );

  // Seeding info.
  $form['seeding'] = array(
    '#type' => 'fieldset',
    '#title' => t('Seeding'),
    '#weight' => 2,
  );

  // Add seeding log to form_state.
  if (!empty($defaults['seeding']['log'])) {
    $form['seeding']['log'] = array(
      '#type' => 'value',
      '#value' => $defaults['seeding']['log'],
    );
  }

  // Add a checkbox for status of seeding log.
  $form['seeding']['done'] = array(
    '#type' => 'checkbox',
    '#title' => t('Completed'),
    '#default_value' => $defaults['seeding']['done'],
  );

  // Seeding date.
  $form['seeding']['date'] = array(
    '#type' => 'date_select',
    '#title' => t('Seeding date'),
    '#date_format' => $date_format,
    '#date_label_position' => 'within',
    '#date_year_range' => '-3:+10',
    '#default_value' => NULL,
  );

  // Only calculate default value if exists.
  if (!empty($defaults['seeding']['date'])) {
    $form['seeding']['date']['#default_value'] = date($date_format, $defaults['seeding']['date']);
  }

  // Seeding location.
  $form['seeding']['location'] = array(
    '#type' => 'textfield',
    '#title' => t( 'Seeding Location'),
    '#autocomplete_path' => 'taxonomy/autocomplete/field_farm_area',
    '#default_value' => $defaults['seeding']['location'],
  );

  // Transplanting info.
  $form['transplanting'] = array(
    '#type' => 'fieldset',
    '#title' => t('Transplanting'),
    '#weight' => 3,
  );

  // Add transplanting log to form_state.
  if (!empty($defaults['transplanting']['log'])) {
    $form['transplanting']['log'] = array(
      '#type' => 'value',
      '#value' => $defaults['transplanting']['log'],
    );
  }

  // Add a checkbox for status of transplanting log.
  $form['transplanting']['done'] = array(
    '#type' => 'checkbox',
    '#title' => t('Completed'),
    '#default_value' => $defaults['transplanting']['done'],
  );

  // Days to transplant.
  $form['transplanting']['days_to_transplant'] = array(
    '#type' => 'textfield',
    '#title' => t('Days to Transplant'),
    '#description' => t('Calculate a transplanting date from days after seeding. This will be calculated if not provided.'),
    '#default_value' => $defaults['transplanting']['days_to_transplant'],
    '#element_validate' => array('element_validate_integer_positive'),
  );

  // Transplanting date.
  $form['transplanting']['date'] = array(
    '#type' => 'date_select',
    '#title' => t('Transplanting date'),
    '#description' => t('Specify a specific transplanting date. This will override the days to transplant field if changed.'),
    '#date_format' => $date_format,
    '#date_label_position' => 'within',
    '#date_year_range' => '-3:+10',
    '#default_value' => NULL,
  );

  // Only calculate default value if exists.
  if (!empty($defaults['transplanting']['date'])) {
    $form['transplanting']['date']['#default_value'] = date($date_format, $defaults['transplanting']['date']);
  }

  // Transplanting location.
  $form['transplanting']['location'] = array(
    '#type' => 'textfield',
    '#title' => t( 'Transplanting Location'),
    '#autocomplete_path' => 'taxonomy/autocomplete/field_farm_area',
    '#default_value' => $defaults['transplanting']['location'],
  );

  // Save quantity measure options.
  $quantity_measure_options = farm_quantity_measure_options();

  // Add quantity fields for seeding and transplanting logs.
  $quantity_log_types = array('seeding', 'transplanting');
  foreach($quantity_log_types as $type) {
    $form[$type]['quantity'] = array(
      '#type' => 'fieldset',
      '#title' => t('Quantity'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );

    // Quantity measure.
    $form[$type]['quantity']['measure'] = array(
      '#type' => 'select',
      '#title' => t('Measure'),
      '#options' => $quantity_measure_options,
      '#default_value' => $defaults[$type]['quantity']['measure'],
    );

    // Quantity value.
    $form[$type]['quantity']['value'] = array(
      '#type' => 'textfield',
      '#title' => t('Value'),
      '#default_value' => $defaults[$type]['quantity']['value'],
    );

    // Quantity units.
    $form[$type]['quantity']['units'] = array(
      '#type' => 'textfield',
      '#title' => t('Units'),
      '#autocomplete_path' => 'taxonomy/autocomplete/field_farm_quantity_units',
      '#default_value' => $defaults[$type]['quantity']['units'],
    );
  }

  // Transplanting info.
  $form['harvest'] = array(
    '#type' => 'fieldset',
    '#title' => t('Harvest'),
    '#weight' => 4,
  );

  // Days to harvest.
  $form['harvest']['days_to_harvest'] = array(
    '#type' => 'textfield',
    '#title' => t('Days to harvest'),
    '#default_value' => $defaults['days_to_harvest'],
    '#element_validate' => array('element_validate_integer_positive'),
  );

  // First harvest date.
  $form['harvest']['first_harvest_date'] = array(
    '#type' => 'date_select',
    '#title' => t('First harvest date'),
    '#description' => t('Date of first harvest. Use this to plan backwards.'),
    '#date_format' => $date_format,
    '#date_label_position' => 'within',
    '#date_year_range' => '-3:+10',
    '#default_value' => NULL,
  );

  // Harvest window.
  $form['harvest']['harvest_window'] = array(
    '#type' => 'textfield',
    '#title' => t('Harvest window'),
    '#default_value' => $defaults['harvest_window'],
    '#element_validate' => array('element_validate_integer_positive'),
  );

  // Planting asset name.
  $form['name'] = array(
    '#type' => 'textfield',
    '#title' => t('Planting Name'),
    '#description' => t('The planting asset name will default to "[Season] [Location] [Crop(s)]" but can be modified here. If both a seeding and a transplanting log are created, the transplanting location will be used.' ),
    '#default_value' => $defaults['name'],
    '#weight' => 6,
  );

  return $form;
}

/**
 * Planting form validation.
 */
function farm_crop_plan_planting_form_validate($form, &$form_state) {

  // Start an array of plantings to validate.
  $plantings = array();

  // First validate any new plantings.
  $plantings[] = array(
    'form_state' => $form_state['values']['new'],
    'form' => $form['new'],
  );

  // Add existing plantings to list for validation.
  if (!empty($form_state['values']['plantings'])) {
    foreach ($form_state['values']['plantings'] as $planting_id => $planting_values) {
      $plantings[] = array(
        'form_state' => $form_state['values']['plantings'][$planting_id],
        'form' => $form['plantings'][$planting_id],
      );
    }
  }

  // Iterate through the submitted planting values.
  foreach($plantings as $form_values) {

    // Load the planting form and form_state.
    $planting = $form_values['form_state'];
    $element = $form_values['form'];

    // Bail if planting has no values.
    if (empty($planting)) {
      return;
    }

    // Load the planting name, default to 'New Planting'
    // if the planting hasn't been created.
    $planting_name = 'New Planting';
    if (!empty($planting['planting'])) {
      $planting_name = $planting['planting']->name;
    }

    // Save harvest info.
    $harvest_date = $planting['harvest']['first_harvest_date'];
    $days_to_harvest = $planting['harvest']['days_to_harvest'];

    // Ensure days to harvest is supplied with harvest date.
    if (!empty($harvest_date) && empty($days_to_harvest)) {
      form_error($element['harvest']['first_harvest_date'], $planting_name . ': ' . t('Days to harvest must be provided with harvest date.'));
    }

    // Check if we can plan backwards.
    $plan_backwards = !empty($harvest_date) && !empty($days_to_harvest);

    // Ensure both seeding date and location are provided.
    $seeding_date = $planting['seeding']['date'];
    $seeding_location = $planting['seeding']['location'];

    // Indicate if the user supplied seeding info.
    $supplied_seeding = !empty($seeding_date) || !empty($seeding_location);

    // Validate seeding info.
    if ($supplied_seeding) {

      // Ensure seeding date is provided if not planning backwards.
      if (!$plan_backwards && empty($seeding_date)) {
        form_error($element['seeding']['date'], $planting_name . ': ' . t('Seeding date must be provided with seeding location.'));
      }
    }

    // Ensure we don't remove an existing log.
    $seeding_log_exists = !empty($planting['seeding']['log']);
    if ($seeding_log_exists && !$supplied_seeding) {
      form_error($element['seeding'], $planting_name . ': ' .  t('Seeding log cannot be removed.'));
    }

    // Ensure both transplanting date and location are provided.
    $days_to_transplant = $planting['transplanting']['days_to_transplant'];
    $transplanting_date = $planting['transplanting']['date'];
    $transplanting_location = $planting['transplanting']['location'];

    // Indicate if the user supplied transplanting info.
    $supplied_transplanting = !empty($days_to_transplant) || !empty($transplanting_date) || !empty($transplanting_location);

    // Validate transplanting info.
    if ($supplied_transplanting) {

      // If days to transplant is provided, ensure a seeding date is provided, or planning backwards.
      if (!empty($days_to_transplant) && (!$plan_backwards && empty($seeding_date))) {
        form_error($element['seeding']['date'], $planting_name . ': ' . t('Seeding date is required to calculate transplanting date from days to transplant.'));
      }

      // Ensure transplanting date is provided.
      if (empty($transplanting_date) && empty($days_to_transplant)) {
        form_error($element['transplanting']['date'], $planting_name . ': ' .  t('Transplanting date must be provided with transplanting location.'));
      }

      // Ensure transplanting date is scheduled after seeding date.
      if (!empty($transplanting_date) && !empty($seeding_date)) {
        if ($transplanting_date <= $seeding_date) {
          form_error($element['transplanting']['date'], $planting_name . ': ' . t('Transplanting date must be after seeding date.'));
        }
      }
    }

    // Ensure we don't remove an existing log.
    $transplanting_log_exists = !empty($planting['transplanting']['log']);
    if ($transplanting_log_exists && !$supplied_transplanting) {
      form_error($element['transplanting'], $planting_name . ': ' .  t('Transplanting log cannot be removed.'));
    }

    // Validate crop.
    $crop = $planting['crop'];
    $crop_required = TRUE;
    if (empty($crop)) {

      // When creating a new planting, only require the crop if
      // a seeding or transplanting log are supplied.
      if (empty($planting['planting']) && !($supplied_seeding || $supplied_transplanting)) {
        $crop_required = FALSE;
      }

      // Set a form error if the corp is required.
      if ($crop_required) {
        form_error($element['crop'], $planting_name . ': ' . t('Crop cannot be empty.'));
      }
    }
  }
}

/**
 * Planting form submit.
 */
function farm_crop_plan_planting_form_submit(&$form, &$form_state) {

  // Load the plan.
  $plan = $form_state['values']['plan'];
  $plan_wrapper = entity_metadata_wrapper('farm_plan', $plan);

  // Get the season(s) from the plan.
  foreach ($plan_wrapper->field_farm_season as $season_wrapper) {
    $seasons[] = $season_wrapper->label();
  }

  // Array of log types to create.
  $log_types = array(
    'seeding' => 'farm_seeding',
    'transplanting' => 'farm_transplanting',
  );

  // Start an array of plantings.
  $plantings = array();

  // Add the new plantings.
  $plantings[] = array(
    'submitted' => $form_state['values']['new'],
    'current' => $form['new'],
  );

  // Add existing plantings to list for validation.
  if (!empty($form_state['values']['plantings'])) {
    foreach ($form_state['values']['plantings'] as $planting_id => $planting_values) {
      $plantings[] = array(
        'submitted' => $planting_values,
        'current' => $form['plantings'][$planting_id],
      );
    }
  }

  // Iterate through plantings and update or create as necessary.
  foreach($plantings as $planting_info) {

    // Save submitted and old values from form.
    $planting_values = $planting_info['submitted'];
    $current_values = $planting_info['current'];

    // Skip if planting has no values.
    if (empty($planting_values)) {
      continue;
    }

    // Start array of logs to create.
    $new_logs = array();

    // Get the submitted planting name.
    $planting_name = $planting_values['name'];

    // If no name was given, build a planting name.
    if (empty($planting_name)) {

      // The "final" location of the planting is assumed to be the transplanting
      // location. If a transplanting is not being created, but a seeding is, then
      // use the seeding location.
      $location = '';
      if (!empty($planting_values['transplanting']['location'])) {
        $location = $planting_values['transplanting']['location'];
      }
      elseif (!empty($planting_values['seeding']['location'])) {
        $location = $planting_values['seeding']['location'];
      }

      // The planting will be named based on the season(s), location and crop.
      $planting_name_parts = array(
        implode('/', $seasons),
        $location,
        $planting_values['crop'],
      );
      $planting_name = implode(' ', $planting_name_parts);
    }

    // Check if we can calculate dates planning backwards.
    if (!empty($planting_values['harvest']['first_harvest_date']) && !empty($planting_values['harvest']['days_to_harvest'])) {

      // Save harvest info.
      $first_harvest_date = $planting_values['harvest']['first_harvest_date'];
      $days_to_harvest = $planting_values['harvest']['days_to_harvest'];

      // Calculate "days after seeding", start with the days to harvest.
      // If a transplanting is included this value will be changed.
      $days_after_seeding = $days_to_harvest;

      // Calculate transplanting date if days to transplant is provided.
      if (!empty($planting_values['transplanting']['days_to_transplant'])) {

        // Save days to transplant.
        $days_to_transplant = $planting_values['transplanting']['days_to_transplant'];

        // Calculate transplanting date.
        $transplanting_timestamp = strtotime('-' . $days_to_harvest . ' days', strtotime($first_harvest_date));
        $planting_values['transplanting']['date'] = strftime('%Y-%m-%d', $transplanting_timestamp);

        // Update days after seeding variable.
        $days_after_seeding = $days_to_transplant + $days_to_harvest;
      }

      // Calculate seeding date.
      $seeding_timestamp = strtotime('-' . $days_after_seeding . ' days', strtotime($first_harvest_date));
      $planting_values['seeding']['date'] = strftime('%Y-%m-%d', $seeding_timestamp);
    }

    // Calculate a transplanting date from seeding date + days to transplant.
    // Only calculate if a seeding date is supplied.
    else if (!empty($planting_values['seeding']['date'])) {

      // Save related values.
      $seeding_date = $planting_values['seeding']['date'];
      $days_to_transplant = &$planting_values['transplanting']['days_to_transplant'];
      $transplanting_date = &$planting_values['transplanting']['date'];

      // Remember if a new transplanting date was specified.
      // Don't consider a new transplanting date that is blank.
      $updated_transplanting_date = !empty($transplanting_date) && $transplanting_date != $current_values['transplanting']['date']['#default_value'];

      // If a new transplanting date was specified, use that
      // and update days to transplant to match.
      if ($updated_transplanting_date) {
        $interval = date_diff(date_create($seeding_date), date_create($transplanting_date));
        $days_to_transplant = $interval->format('%a');
      }

      // Otherwise if days to transplant was specified, calculate a new transplanting date.
      if (!$updated_transplanting_date && !empty($days_to_transplant)) {
        $transplanting_timestamp = strtotime('+' . $days_to_transplant . ' days', strtotime($seeding_date));
        $transplanting_date = strftime('%Y-%m-%d', $transplanting_timestamp);
      }
    }

    // Check if the submitted planting already exists.
    if (!empty($planting_values['planting'])) {

      // Get the planting asset.
      $planting_asset = $planting_values['planting'];

      // Keep track if planting was updated, so we can set a message afterwards.
      $updated_planting = FALSE;

      // Update the planting name if needed.
      // This is done before updating logs so that they will
      // be generated with the correct name.
      if ($planting_asset->name != $planting_name) {

        // Get an entity metadata wrapper for the planting.
        $planting_wrapper = entity_metadata_wrapper('farm_asset', $planting_asset);

        // Update the name.
        $planting_wrapper->name = $planting_name;

        // Save the planting.
        $planting_wrapper->save();

        // Remember the planting was updated.
        $updated_planting = TRUE;
      }

      // If the crop changed, update the planting.
      if ($planting_values['crop'] != $current_values['crop']['#default_value']) {

        // Get an entity metadata wrappers for the planting.
        $planting_wrapper = entity_metadata_wrapper('farm_asset', $planting_asset);

        // Get the crop term (or create a new one), and add it to the planting.
        $crop = farm_term($planting_values['crop'], 'farm_crops');
        $planting_wrapper->field_farm_crop->set(array(NULL));
        $planting_wrapper->field_farm_crop[] = $crop;

        // Save the planting.
        $planting_wrapper->save();

        // Remember that the planting was updated.
        $updated_planting = TRUE;
      }

      // Load values for logs that need to be created.
      foreach ($log_types as $name => $type) {

        // Existing values.
        $current_log_values = $current_values[$name];

        // New values.
        $new_date = $planting_values[$name]['date'];
        $new_location = $planting_values[$name]['location'];

        // Skip if date is not provided.
        if (empty($new_date)) {
          continue;
        }

        // Check for existing log.
        if (empty($planting_values[$name]['log'])) {

          // Add log info to create later.
          $new_logs[] = array(
            'type' => $type,
            'planting_asset' => $planting_asset,
            'done' => $planting_values[$name]['done'],
            'date' => $new_date,
            'location' => $new_location,
            'quantity' => $planting_values[$name]['quantity'],
          );

          // Skip updating.
          continue;
        }

        // Keep track if the log was updated.
        $updated_log = FALSE;

        // If the Planting crop changed, update the log name.
        if ($updated_planting) {

          // Blank out the log name to auto-regenerate.
          $planting_values[$name]['log']->name = '';
          log_save($planting_values[$name]['log']);

          // Remember that the log was updated.
          $updated_log = TRUE;
        }

        // Check if the log status changed.
        $old_status = $current_log_values['done']['#default_value'];
        $new_status = $planting_values[$name]['done'];
        if ($old_status != $new_status) {

          // Update log.
          $planting_values[$name]['log']->done = $new_status;
          log_save($planting_values[$name]['log']);
          $updated_log = TRUE;
        }

        // If the log date changed, update the log.
        $default_date = !empty($current_log_values['date']['#default_value']) ? $current_log_values['date']['#default_value'] : NULL;
        if ($new_date != $default_date) {

          // Update the log timestamp.
          $timestamp = strtotime($new_date);
          $planting_values[$name]['log']->timestamp = $timestamp;

          log_save($planting_values[$name]['log']);

          // Remember that the log was updated.
          $updated_log = TRUE;
        }

        // Get the existing location.
        $default_location = !empty($current_log_values['location']['#default_value']) ? $current_log_values['location']['#default_value'] : NULL;

        // If the location changed, update the log.
        if ($new_location != $default_location) {

          // Load new areas.
          $areas = farm_term_parse_names($new_location, 'farm_areas', TRUE);

          // If the log has a movement associated with it...
          if (!empty($planting_values[$name]['log']->field_farm_movement[LANGUAGE_NONE][0]['value'])) {

            // Load the movement information associated with the log.
            $movement = field_collection_item_load($planting_values[$name]['log']->field_farm_movement[LANGUAGE_NONE][0]['value']);
            $movement_wrapper = entity_metadata_wrapper('field_collection_item', $movement);
            $movement_wrapper->field_farm_move_to = array();

            // Add areas to movement.
            foreach ($areas as $area) {
              $area = taxonomy_term_load($area->tid);
              $movement_wrapper->field_farm_move_to[] = $area;
            }
            $movement_wrapper->save();
          }

          // Or, if the log does not have a movement associated with it...
          else {

            // Add a new movement to the log.
            $movement = entity_create('field_collection_item', array('field_name' => 'field_farm_movement'));
            $movement->setHostEntity('log', $planting_values[$name]['log']);

            // Create an entity wrapper for the adjustment.
            $movement_wrapper = entity_metadata_wrapper('field_collection_item', $movement);

            // Iterate through the areas and add each to the "Move to" field.
            foreach ($areas as $area) {
              $movement_wrapper->field_farm_move_to[] = $area;
            }

            // Save the movement.
            $movement_wrapper->save();
          }

          // Remember that the log was updated.
          $updated_log = TRUE;
        }

        // Check if the log quantity changed.
        // Create array of values to compare.
        $current_quantity_values = array(
          'measure' => $current_log_values['quantity']['measure']['#default_value'],
          'value' => $current_log_values['quantity']['value']['#default_value'],
          'units' => $current_log_values['quantity']['units']['#default_value'],
        );
        $new_quantity_values = $planting_values[$name]['quantity'];
        $quantity_changed = $current_quantity_values != $new_quantity_values;

        // Update log quantities.
        if ($quantity_changed) {

          // Load the log entity metadata wrapper.
          $log_wrapper = entity_metadata_wrapper('log', $planting_values[$name]['log']);

          // Check if submitted quantity has a value.
          // Quantities are only saved if a value is included.
          $has_quantity = !(empty($planting_values[$name]['quantity']['value']));

          // Build new quantity measurements.
          $measurements = array();
          if ($has_quantity) {
            $measurements[] = $planting_values[$name]['quantity'];
          }

          // Check for existing quantity.
          if (isset($log_wrapper->field_farm_quantity[0])) {

            // Get the first quantity.
            $quantity_wrapper = $log_wrapper->field_farm_quantity[0];

            // Update existing quantity.
            if ($has_quantity) {
              // Get the measurement.
              $measurement = $measurements[0];

              // Set the quantity measure, if available.
              if (!empty($measurement['measure'])) {
                $quantity_wrapper->field_farm_quantity_measure->set($measurement['measure']);
              }

              // Set the quantity value, if available.
              if (!empty($measurement['value'])) {

                // Clear the old value.
                $quantity_wrapper->field_farm_quantity_value = array();

                $value_fraction = fraction_from_decimal($measurement['value']);
                $quantity_wrapper->field_farm_quantity_value->numerator->set($value_fraction->getNumerator());
                $quantity_wrapper->field_farm_quantity_value->denominator->set($value_fraction->getDenominator());
              }

              // Set the units, if available.
              if (!empty($measurement['units'])) {

                // Load/create units term.
                $units_term = farm_term($measurement['units'], 'farm_quantity_units');

                // Set the quantity units.
                $quantity_wrapper->field_farm_quantity_units = $units_term;
              }

              // Save the quantity.
              $quantity_wrapper->save();
            }
            // Remove the first quantity.
            else {
              entity_delete('field_collection_item', $quantity_wrapper->item_id->value());
              unset($planting_values[$name]['log']->field_farm_quantity[LANGUAGE_NONE][0]);
            }
          }
          // No quantities exist, create a new one.
          else if ($has_quantity) {

            // If there are quantity measurements, add them to the log.
            if (!empty($measurements)) {
              farm_quantity_log_add_measurements($planting_values[$name]['log'], $measurements);
            }
          }

          // Save the log and remember that we updated it.
          log_save($planting_values[$name]['log']);
          $updated_log = TRUE;
        }

        // If the log was updated, display a message.
        if ($updated_log) {
          $log_name = entity_label('log', $planting_values[$name]['log']);
          $log_uri = entity_uri('log', $planting_values[$name]['log']);
          $log_url = url($log_uri['path']);
          drupal_set_message(
            t('The @log_type log <a href="@log_url">@log_name</a> was updated.',
              array('@log_type' => $name, '@log_url' => $log_url, '@log_name' => $log_name))
          );
        }
      }

      // If the planting was updated, display a message.
      if ($updated_planting) {
        $planting_name = entity_label('farm_asset', $planting_asset);
        $planting_uri = entity_uri('farm_asset', $planting_asset);
        $planting_url = url($planting_uri['path']);
        drupal_set_message(
          t('The planting asset <a href="@planting_url">@planting_name</a> was updated.',
          array('@planting_url' => $planting_url, '@planting_name' => $planting_name))
        );
      }
    }

    // Create new planting if one doesn't exist.
    if (empty($planting_values['planting'])) {

      // Bail if no crop was provided.
      // The prevents creating new plantings when the form is empty.
      if (empty($planting_values['crop'])) {
        continue;
      }

      // Get the crop name that was entered and create/load it's term.
      $crop_term = farm_term($planting_values['crop'], 'farm_crops');

      // Create a new planting asset.
      $values = array(
        'type' => 'planting',
        'name' => $planting_name,
      );
      $planting_asset = entity_create('farm_asset', $values);
      $planting_wrapper = entity_metadata_wrapper('farm_asset', $planting_asset);

      // Add the season(s).
      foreach ($plan_wrapper->field_farm_season as $season_wrapper) {
        $planting_wrapper->field_farm_season[] = $season_wrapper;
      }

      // Add the crop.
      $planting_wrapper->field_farm_crop[] = $crop_term;

      // Save the planting.
      $planting_wrapper->save();

      // Link the asset to this crop plan.
      farm_plan_link_record('farm_crop_plan_planting', $plan->id, $planting_asset->id);

      // Set a message.
      $label = entity_label('farm_asset', $planting_asset);
      $uri = entity_uri('farm_asset', $planting_asset);
      drupal_set_message('Planting created: ' . l($label, $uri['path']));

      // Load values for logs that need to be created.
      foreach ($log_types as $name => $type) {
        $date = $planting_values[$name]['date'];
        $location = $planting_values[$name]['location'];
        if (!empty($date)) {
          $new_logs[] = array(
            'type' => $type,
            'planting_asset' => $planting_asset,
            'done' => $planting_values[$name]['done'],
            'date' => $date,
            'location' => $location,
            'quantity' => $planting_values[$name]['quantity'],
          );
        }
      }
    }

    // Iterate through the logs.
    foreach ($new_logs as $log_values) {

      // If no details were provided, skip it.
      if (empty($log_values)) {
        continue;
      }

      // Skip if no planting asset is provided.
      if (empty($log_values['planting_asset'])) {
        continue;
      }

      // Get the log type.
      $type = $log_values['type'];

      // Save the log values.
      $planting_asset = $log_values['planting_asset'];

      // Convert the date to a timestamp.
      $timestamp = strtotime($log_values['date']);

      // If the location is available, load areas.
      $areas = array();
      if (!empty($log_values['location'])) {
        $areas = farm_term_parse_names($log_values['location'], 'farm_areas', TRUE);
      }

      // Save the log status.
      $done = $log_values['done'];

      // If there is a location, create a movement log.
      if (!empty($log_values['location'])) {
        $log = farm_movement_create($planting_asset, $areas, $timestamp, $type, $done);
      }

      // Otherwise, create a normal log (without movement location).
      else {
        $log = farm_log_create($type, '', $timestamp, $done, array($planting_asset));
      }

      // Build quantity measurements.
      $measurements = array();
      if (!empty($log_values['quantity']['value'])) {
        $measurements[] = $log_values['quantity'];
      }

      // If there are quantity measurements, add them to the log.
      if (!empty($measurements)) {
        farm_quantity_log_add_measurements($log, $measurements);
      }

      // Create an entity metadata wrapper for the log.
      $log_wrapper = entity_metadata_wrapper('log', $log);

      // Save the log.
      $log_wrapper->save();

      // Link the log to the crop plan.
      if ($type == 'farm_seeding') {
        $relationship = 'farm_crop_plan_seeding';
      }
      elseif ($type == 'farm_transplanting') {
        $relationship = 'farm_crop_plan_transplanting';
      }
      farm_plan_link_record($relationship, $plan->id, $log->id, array('asset_id' => $planting_asset->id));
    }

    // Build array of crop plan planting attributes to update.
    $record = array(
      'plan_id' => $plan->id,
      'asset_id' => $planting_asset->id,
    );

    // Update days_to_transplant.
    if (!empty($planting_values['transplanting']['days_to_transplant'])) {
      $record['days_to_transplant'] = $planting_values['transplanting']['days_to_transplant'];
    }

    // Update days_to_harvest. Replace empty string with NULL.
    $days_to_harvest = $planting_values['harvest']['days_to_harvest'];
    if (empty($days_to_harvest)) {
      $days_to_harvest = NULL;
    }
    $record['days_to_harvest'] = $days_to_harvest;

    // Update harvest_window. Replace empty string with NULL.
    $harvest_window = $planting_values['harvest']['harvest_window'];
    if (empty($harvest_window)) {
      $harvest_window = NULL;
    }
    $record['harvest_window'] = $harvest_window;

    // Update the Crop Plan Planting.
    drupal_write_record('farm_crop_plan_planting', $record, array('plan_id', 'asset_id'));
  }
}
