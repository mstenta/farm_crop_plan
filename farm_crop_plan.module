<?php

/**
 * @file
 * farmOS crop planning module.
 */

include_once 'farm_crop_plan.features.inc';

/**
 * Implements hook_farm_ui_entities().
 */
function farm_crop_plan_farm_ui_entities() {
  return array(
    'farm_plan' => array(
      'crop' => array(
        'label' => t('Crop Plan'),
        'label_plural' => t('Crop Plans'),
        'view' => 'farm_crop_plan',
      ),
    ),
  );
}

/**
 * Implements hook_entity_view().
 */
function farm_crop_plan_entity_view($entity, $type, $view_mode, $langcode) {

  // Only proceed if this is the full view mode of a crop plan.
  if (!($type == 'farm_plan' && $entity->type == 'crop' && $view_mode == 'full')) {
    return;
  }

  // Reference the entity content object.
  $content = &$entity->content;

  $content['plantings'] = drupal_get_form('farm_crop_plan_planting_form', $entity);
}

/**
 * Planting form.
 */
function farm_crop_plan_planting_form($form, &$form_state, $plan) {

  // Display the form below crop plan attributes.
  $form['#weight'] = 100;
  $form['#tree'] = TRUE;

  // Store the plan entity for use in submit.
  $form['plan'] = array(
    '#type' => 'value',
    '#value' => $plan,
  );

  // Add Planting fieldset.
  $form['new'] = farm_crop_plan_planting_details_form($plan);
  $form['new']['#type'] = 'fieldset';
  $form['new']['#title'] = t('Add a planting');
  $form['new']['#collapsible'] = TRUE;
  $form['new']['#collapsed'] = TRUE;

  // Display Plantings associated with this plan.
  // Load asset(s) associated with this plan.
  $asset_ids = farm_plan_linked_records('asset', $plan->id);
  $assets = farm_asset_load_multiple($asset_ids);

  // Iterate through the assets to make a list of plantings.
  $plantings = array();
  foreach ($assets as $asset) {

    // If the asset is not a planting, skip it.
    if ($asset->type != 'planting') {
      continue;
    }

    // Add it to the list.
    $plantings[] = $asset;
  }

  // Iterate through the plantings and build forms.
  foreach ($plantings as $planting) {

    // Add a planting details form.
    $planting_form = farm_crop_plan_planting_details_form($plan, $planting);

    // Make it a fieldset with a title.
    $planting_form['#type'] = 'fieldset';
    $planting_form['#collapsible'] = TRUE;
    $planting_form['#collapsed'] = TRUE;
    $planting_form['#title'] = t('Planting') . ': ' . entity_label('farm_asset', $planting);

    // Add the planting to the form values, for use in form submission.
    $planting_form['planting'] = array(
      '#type' => 'value',
      '#value' => $planting,
    );

    // If the planting has an ID, add a link to remove it.
    if (!empty($planting->id)) {
      $planting_form['remove'] = array(
        '#type' => 'markup',
        '#markup' => l(t('Remove'), 'farm/plan/' . $plan->id . '/asset/' . $planting->id . '/delete', array('query' => array('destination' => current_path()))),
        '#weight' => 100,
      );
    }

    $form['plantings'][$planting->id] = $planting_form;
  }

  // Submit button for saving all changes.
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save Plantings'),
    '#weight' => 100,
  );

  return $form;
}

/**
 * Planting details sub-form.
 */
function farm_crop_plan_planting_details_form($plan, $planting = NULL) {

  // If a plan ID is not available, bail.
  if (empty($plan->id)) {
    return array();
  }

  // Define the date format for logs.
  $date_format = 'Y-m-d';

  $defaults = array(
    'crop' => NULL,
    'seeding' => array(
      'date' => NULL,
      'location' => '',
    ),
    'transplanting' => array(
      'date' => NULL,
      'location' => '',
    ),
  );

  if (!empty($planting)) {
    // Get the planting metadata wrapper.
    $planting_wrapper = entity_metadata_wrapper('farm_asset', $planting);

    // Get the crop name.
    $defaults['crop'] = $planting_wrapper->field_farm_crop->label();

    // Load linked logs.
    $log_ids = farm_plan_linked_records('log', $plan->id);

    // Define log types to create on planting assets.
    $log_types = array(
      'transplanting' => 'farm_transplanting',
      'seeding' => 'farm_seeding'
    );

    foreach($log_types as $label => $type) {
      // Find logs that reference the planting.
      $query = farm_log_asset_query($planting->id, 0, NULL, $type);
      $query->addField('ss_log', 'id');
      $result = $query->execute();
      foreach ($result as $row) {

        // Check if the log is included in the plan.
        if (!empty($row->id) && in_array($row->id, $log_ids)) {

          // Load the log.
          $log = log_load($row->id);

          // Save the log for later.
          $defaults[$label]['log'] = $log;

          // Update default form values associated with the log type.
          $defaults[$label]['date'] = $log->timestamp;

          // Load areas referenced by the log.
          $areas = array();
          if (!empty($log->field_farm_movement[LANGUAGE_NONE][0]['value'])) {
            $movement = field_collection_item_load($log->field_farm_movement[LANGUAGE_NONE][0]['value']);
            if (!empty($movement->field_farm_move_to[LANGUAGE_NONE])) {
              foreach ($movement->field_farm_move_to[LANGUAGE_NONE] as $area_ref) {

                // If the term ID is empty, skip it.
                if (empty($area_ref['tid'])) {
                  continue;
                }
                $area_id = $area_ref['tid'];

                // Load the area. If it can't be loaded, skip it.
                $area = taxonomy_term_load($area_id);
                if (empty($area)) {
                  continue;
                }

                // Add to the list of area options.
                $areas[] = entity_label('taxonomy_term', $area);
              }
            }
          }

          $defaults[$label]['location'] = implode(', ', $areas);
        }
      }
    }
  }

  // Crop.
  $form['crop'] = array(
    '#type' => 'textfield',
    '#title' => t('Crop/variety'),
    '#autocomplete_path' => 'taxonomy/autocomplete/field_farm_crop',
    '#default_value' => $defaults['crop'],
    '#weight' => 1,
  );

  // Seeding info.
  $form['seeding'] = array(
    '#weight' => 2,
  );

  // Seeding date.
  $form['seeding']['date'] = array(
    '#type' => 'date_select',
    '#title' => t('Seeding date'),
    '#date_format' => $date_format,
    '#date_label_position' => 'within',
    '#date_year_range' => '-3:+10',
  );

  // Only set default value if exists.
  if (!empty($defaults['seeding']['date'])) {
    $form['seeding']['date']['#default_value'] = date($date_format, $defaults['seeding']['date']);
  }

  // Add seeding log to form_state.
  if (!empty($defaults['seeding']['log'])) {
    $form['seeding']['log'] = array(
      '#type' => 'value',
      '#value' => $defaults['seeding']['log'],
    );
  }

  // Seeding location.
  $form['seeding']['location'] = array(
    '#type' => 'textfield',
    '#title' => t( 'Seeding Location'),
    '#autocomplete_path' => 'taxonomy/autocomplete/field_farm_area',
    '#default_value' => $defaults['seeding']['location'],
  );

  // Transplanting info.
  $form['transplanting'] = array(
    '#weight' => 3,
  );

  // Transplanting date.
  $form['transplanting']['date'] = array(
    '#type' => 'date_select',
    '#title' => t('Transplanting date'),
    '#date_format' => $date_format,
    '#date_label_position' => 'within',
    '#date_year_range' => '-3:+10',
  );

  // Only set default value if exists.
  if (!empty($defaults['transplanting']['date'])) {
    $form['transplanting']['date']['#default_value'] = date($date_format, $defaults['transplanting']['date']);
  }

  // Add transplanting log to form_state.
  if (!empty($defaults['transplanting']['log'])) {
    $form['transplanting']['log'] = array(
      '#type' => 'value',
      '#value' => $defaults['transplanting']['log'],
    );
  }

  // Transplanting location.
  $form['transplanting']['location'] = array(
    '#type' => 'textfield',
    '#title' => t( 'Transplanting Location'),
    '#autocomplete_path' => 'taxonomy/autocomplete/field_farm_area',
    '#default_value' => $defaults['transplanting']['location'],
  );

  return $form;
}

/**
 * Planting form validation.
 */
function farm_crop_plan_planting_form_validate($form, &$form_state) {

  // Start an array of plantings to validate.
  $plantings = array();

  // First validate any new plantings.
  $plantings[] = array(
    'form_state' => $form_state['values']['new'],
    'form' => $form['new'],
  );

  // Add existing plantings to list for validation.
  if (!empty($form_state['values']['plantings'])) {
    foreach ($form_state['values']['plantings'] as $planting_id => $planting_values) {
      $plantings[] = array(
        'form_state' => $form_state['values']['plantings'][$planting_id],
        'form' => $form['plantings'][$planting_id],
      );
    }
  }

  foreach($plantings as $form_values) {

    // Load the planting form and form_state.
    $planting = $form_values['form_state'];
    $element = $form_values['form'];

    // Bail if planting has no values.
    if (empty($planting)) {
      return;
    }

    // Load the planting name, default to 'New Planting'
    // if the planting hasn't been created.
    $planting_name = 'New Planting';
    if (!empty($planting['planting'])) {
      $planting_name = $planting['planting']->name;
    }

    // Ensure both seeding date and location are provided.
    $seeding_date = $planting['seeding']['date'];
    $seeding_location = $planting['seeding']['location'];

    // Indicate if the user supplied seeding info.
    $supplied_seeding = !empty($seeding_date) || !empty($seeding_location);

    // Validate seeding info.
    if ($supplied_seeding) {
      if (empty($seeding_date)) {
        form_error($element['seeding']['date'], $planting_name . ': ' . t('Seeding date must be provided with seeding location.'));
      }

      if (empty($seeding_location)) {
        form_error($element['seeding']['location'], $planting_name . ': ' .  t('Seeding location must be provided with seeding date.'));
      }
    }

    // Ensure we don't remove an existing log.
    $seeding_log_exists = !empty($planting['seeding']['log']);
    if ($seeding_log_exists && !$supplied_seeding) {
      form_error($element['seeding'], $planting_name . ': ' .  t('Seeding log cannot be removed.'));
    }


    // Ensure both transplanting date and location are provided.
    $transplanting_date = $planting['transplanting']['date'];
    $transplanting_location = $planting['transplanting']['location'];

    // Indicate if the user supplied transplanting info.
    $supplied_transplanting = !empty($transplanting_date) || !empty($transplanting_location);

    // Validate transplanting info.
    if ($supplied_transplanting) {
      if (empty($transplanting_date)) {
        form_error($element['transplanting']['date'], $planting_name . ': ' .  t('Transplanting date must be provided with transplanting location.'));
      }

      if (empty($transplanting_location)) {
        form_error($element['transplanting']['location'], $planting_name . ': ' .  t('Transplanting location must be provided with transplanting date.'));
      }
    }

    // Ensure we don't remove an existing log.
    $transplanting_log_exists = !empty($lanting['transplanting']['log']);
    if ($transplanting_log_exists && !$supplied_transplanting) {
      form_error($element['transplanting'], $planting_name . ': ' .  t('Transplanting log cannot be removed.'));
    }

    // Validate crop.
    $crop = $planting['crop'];
    $crop_required = TRUE;
    if (empty($crop)) {

      // When creating a new planting, only require the crop if
      // a seeding or transplanting log are supplied.
      if (empty($planting['planting']) && !($supplied_seeding || $supplied_transplanting)) {
        $crop_required = FALSE;
      }

      if ($crop_required) {
        form_error($element['crop'], $planting_name . ': ' . t('Crop cannot be empty.'));
      }
    }
  }
}

/**
 * Planting form submit.
 */
function farm_crop_plan_planting_form_submit(&$form, &$form_state) {

  // Load the plan.
  $plan = $form_state['values']['plan'];
  $plan_wrapper = entity_metadata_wrapper('farm_plan', $plan);

  // Get the season from the plan.
  $season = $plan_wrapper->field_farm_season->label();

  // Array of log types to create.
  $log_types = array(
    'seeding' => 'farm_seeding',
    'transplanting' => 'farm_transplanting',
  );

  // Start an array of plantings.
  $plantings = array();

  // Add the new plantings.
  $plantings[] = $form_state['values']['new'];

  // Add existing plantings to list for validation.
  if (!empty($form_state['values']['plantings'])) {
    foreach ($form_state['values']['plantings'] as $planting_id => $planting_values) {
      $plantings[] = $form_state['values']['plantings'][$planting_id];
    }
  }

  // Iterate through plantings and update or create as necessary.
  foreach($plantings as $planting_values) {

    // Bail if planting has no values.
    if (empty($planting_values)) {
      return;
    }

    // Start array of logs to create.
    $new_logs = array();

    // Check if the submitted planting already exists.
    if (!empty($planting_values['planting'])) {

      // Get the planting id.
      $planting_id = $planting_values['planting']->id;

      // Keep track if planting was updated, so we can set a message afterwards.
      $updated_planting = FALSE;

      // If the crop changed, update the planting.
      if ($planting_values['crop'] != $form['plantings'][$planting_id]['crop']['#default_value']) {

        // Get an entity metadata wrappers for the planting.
        $planting_wrapper = entity_metadata_wrapper('farm_asset', $planting_values['planting']);

        // Get the crop term (or create a new one), and add it to the planting.
        $crop = farm_term($planting_values['crop'], 'farm_crops');
        $planting_wrapper->field_farm_crop->set(array(NULL));
        $planting_wrapper->field_farm_crop[] = $crop;

        // Recreate the planting name.
        $planting_name_parts = array(
          $season,
          $planting_values['crop'],
        );
        $planting_name = implode(' ', $planting_name_parts);
        $planting_wrapper->name = $planting_name;

        // Save the planting.
        $planting_wrapper->save();

        // Remember that the planting was updated.
        $updated_planting = TRUE;
      }

      // Load values for logs that need to be created.
      foreach ($log_types as $name => $type) {

        // Existing values.
        $current_log_values = $form['plantings'][$planting_id][$name];

        // New values.
        $new_date = $planting_values[$name]['date'];
        $new_location = $planting_values[$name]['location'];

        // Skip if date or location is not provided.
        if (empty($new_date) || empty($new_location)) {
          continue;
        }

        // Check for existing log.
        if (empty($planting_values[$name]['log'])) {

          // Add log info to create later.
          $new_logs[] = array(
            'type' => $type,
            'planting_asset' => $planting_values['planting'],
            'date' => $new_date,
            'location' => $new_location,
          );

          // Skip updating.
          continue;
        }

        // Keep track if the log was updated.
        $updated_log = FALSE;

        // If the planting date changed, update the log.
        $default_date = !empty($current_log_values['date']['#default_value']) ? $current_log_values['date']['#default_value'] : NULL;
        if ($new_date != $default_date) {

          // Update the log timestamp.
          $timestamp = strtotime($new_date);
          $planting_values[$name]['log']->timestamp = $timestamp;

          // Mark the log as done if the date is in the past.
          $done = $timestamp < REQUEST_TIME;
          $planting_values[$name]['log']->done = $done;

          log_save($planting_values[$name]['log']);

          // Remember that the log was updated.
          $updated_log = TRUE;
        }

        // Get the existing location.
        $default_location = !empty($current_log_values['location']['#default_value']) ? $current_log_values['location']['#default_value'] : NULL;

        // If the location changed, update the log.
        if ($new_location != $default_location) {

          // Load the movement information associated with the log.
          if (!empty($planting_values[$name]['log']->field_farm_movement[LANGUAGE_NONE][0]['value'])) {
            $movement = field_collection_item_load($planting_values[$name]['log']->field_farm_movement[LANGUAGE_NONE][0]['value']);
            $movement_wrapper = entity_metadata_wrapper('field_collection_item', $movement);
            $movement_wrapper->field_farm_move_to = array();

            // Load areas.
            $areas = farm_area_parse_names($new_location, TRUE);
            foreach ($areas as $area) {
              $area = taxonomy_term_load($area->tid);
              $movement_wrapper->field_farm_move_to[] = $area;
            }
            $movement_wrapper->save();
          }

          // Remember that the log was updated.
          $updated_log = TRUE;
        }

        // If the log was updated, display a message.
        if ($updated_log) {
          $log_name = entity_label('log', $planting_values[$name]['log']);
          drupal_set_message(t('The %log_type log %log_name was updated.', array('%log_type' => $name, '%log_name' => $log_name)));
        }
      }

      // If the planting was updated, display a message.
      if ($updated_planting) {
        $planting_name = entity_label('farm_asset', $planting_values['planting']);
        drupal_set_message(t('The planting asset %planting_name was updated.', array('%planting_name' => $planting_name)));
      }
    }

    // Create new planting if one doesn't exist.
    if (empty($planting_values['planting'])) {

      // Bail if no crop was provided.
      // The prevents creating new plantings when the form is empty.
      if (empty($planting_values['crop'])) {
        continue;
      }

      // Get the crop name that was entered and create/load it's term.
      $crop_term = farm_term($planting_values['crop'], 'farm_crops');
      $crop = $crop_term->name;

      // Assemble a planting name.
      $planting_name_parts = array(
        $season,
        $crop,
      );
      $planting_name = implode(' ', $planting_name_parts);

      // Create a new planting asset.
      $values = array(
        'type' => 'planting',
        'name' => $planting_name,
      );
      $planting_asset = entity_create('farm_asset', $values);
      $planting_wrapper = entity_metadata_wrapper('farm_asset', $planting_asset);

      // Add the season.
      $planting_wrapper->field_farm_season = $plan_wrapper->field_farm_season;

      // Add the crop.
      $planting_wrapper->field_farm_crop[] = $crop_term;

      // Save the planting.
      $planting_wrapper->save();

      // Link the asset to this crop plan.
      farm_plan_link_record('asset', $plan->id, $planting_asset->id);

      // Set a message.
      $label = entity_label('farm_asset', $planting_asset);
      $uri = entity_uri('farm_asset', $planting_asset);
      drupal_set_message('Planting created: ' . l($label, $uri['path']));

      // Load values for logs that need to be created.
      foreach ($log_types as $name => $type) {
        $date = $planting_values[$name]['date'];
        $location = $planting_values[$name]['location'];

        if (!empty($date) && !empty($location)) {
          $new_logs[] = array(
            'type' => $type,
            'planting_asset' => $planting_asset,
            'date' => $date,
            'location' => $location,
          );
        }
      }
    }

    // Iterate through the logs.
    foreach ($new_logs as $log_values) {

      // If no details were provided, skip it.
      if (empty($log_values)) {
        continue;
      }

      // Skip if no planting asset is provided.
      if (empty($log_values['planting_asset'])) {
        continue;
      }

      // Get the log type.
      $type = $log_values['type'];

      // Save the log values.
      $planting_asset = $log_values['planting_asset'];

      // Convert the date to a timestamp.
      $timestamp = strtotime($log_values['date']);

      // If the location is available, load areas.
      $areas = array();
      if (!empty($log_values['location'])) {
        $areas = farm_area_parse_names($log_values['location'], TRUE);
      }

      // Mark the log as done if the date is in the past.
      $done = $timestamp < REQUEST_TIME;

      // If there is a location, create a movement log.
      if (!empty($log_values['location'])) {
        $log = farm_movement_create($planting_asset, $areas, $timestamp, $type, $done);
      } // Otherwise, create a normal log (without movement location).
      else {
        $log = farm_log_create($type, '', $timestamp, $done, array($planting_asset));
      }

      // Create an entity metadata wrapper for the log.
      $log_wrapper = entity_metadata_wrapper('log', $log);

      // Save the log.
      $log_wrapper->save();

      // Link the log to the crop plan.
      farm_plan_link_record('log', $plan->id, $log->id);
    }
  }
}
