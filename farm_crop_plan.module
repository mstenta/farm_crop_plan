<?php

/**
 * @file
 * farmOS crop planning module.
 */

include_once 'farm_crop_plan.features.inc';

/**
 * Implements hook_help().
 */
function farm_crop_plan_help($path, $arg) {

  // Add help text to the crop plan list page.
  if ($path == 'farm/plans/forest') {
    $help = '<p>' . t('This page lists all forest plans. Select one from the list below to view it, or click "Add forest plan" to create a new one.') . '</p>';
    $help .= '<p>' . t('Plans can be archived for future reference. To view archived plans, use the "Filter" options in the list below.') . '</p>';
    return $help;
  }

  // If the path starts with 'farm/plan/%', then load the plan and see if it is
  // a crop plan. If not, bail. Otherwise continue.
  if (strpos($path, 'farm/plan/%') === 0) {
    $plan = farm_plan_load($arg[2]);
    if (empty($plan) || $plan->type != 'crop') {
      return '';
    }
  }

  // Add help text to all farm/plan/% paths.
  switch ($path) {

    // Plan add/edit form.
    case 'farm/plan/add/crop':
    case 'farm/plan/%/edit':
      $help = '<p>' . t('Use the form below to configure the basic settings for this crop plan. Plantings can be added/edited on the main "Plan" tab.') . '</p>';
      return $help;

    // Plan view page.
    case 'farm/plan/%':
    case 'farm/plan/%/view':
      $help = '<p>' . t('This page summarizes the details of this crop plan. New plantings can be added to the plan via the "Add a planting" form at the bottom.') . '</p>';
      $help .= '<p>' . t('The timeline will display all plantings based on their seeding/transplanting/harvest dates, and can be viewed "by planting" (one row per planting) or "by area" (one row per area).') . '</p>';
      $help .= '<p>' . t('To edit the plan, click the "Settings" tab.') . '</p>';
      return $help;
  }
}

/**
 * Implements hook_farm_ui_entities().
 */
function farm_crop_plan_farm_ui_entities() {
  return array(
    'farm_plan' => array(
      'crop' => array(
        'label' => t('Crop Plan'),
        'label_plural' => t('Crop Plans'),
        'view' => 'farm_crop_plan',
      ),
    ),
  );
}

/**
 * Implements hook_farm_plan_record_relationships().
 */
function farm_crop_plan_farm_plan_record_relationships() {
  return array(
    'farm_crop_plan_planting' => array(
      'label' => t('Planting'),
      'entity_type' => 'farm_asset',
      'entity_pk' => 'id',
      'table' => 'farm_crop_plan_planting',
      'field' => 'asset_id',
    ),
    'farm_crop_plan_seeding' => array(
      'label' => t('Seeding'),
      'entity_type' => 'log',
      'entity_pk' => 'id',
      'table' => 'farm_crop_plan_planting',
      'field' => 'seeding_id',
      'required' => FALSE,
    ),
    'farm_crop_plan_transplanting' => array(
      'label' => t('Transplanting'),
      'entity_type' => 'log',
      'entity_pk' => 'id',
      'table' => 'farm_crop_plan_planting',
      'field' => 'transplanting_id',
      'required' => FALSE,
    ),
  );
}

/**
 * Access callback for crop plan tabs.
 */
function farm_crop_plan_access($plan) {

  // If the plan is not a crop plan, deny access.
  if ($plan->type != 'crop') {
    return FALSE;
  }

  // Defer to the farm plan access callback.
  return farm_plan_access('update', $plan);
}

/**
 * Implements hook_theme().
 */
function farm_crop_plan_theme($existing, $type, $theme, $path) {
  return array(
    'farm_crop_plan_timeline' => array(
      'render element' => 'form',
      'file' => 'farm_crop_plan.theme.inc',
    ),
  );
}

/**
 * Implements hook_entity_view().
 */
function farm_crop_plan_entity_view($entity, $type, $view_mode, $langcode) {

  // Only proceed if this is the full view mode of a crop plan.
  if (!($type == 'farm_plan' && $entity->type == 'crop' && $view_mode == 'full')) {
    return;
  }

  // Reference the entity content object.
  $content = &$entity->content;

  // Add the crop plan form.
  drupal_add_css(drupal_get_path('module', 'farm_crop_plan') . '/farm_crop_plan.css');
  drupal_add_js(drupal_get_path('module', 'farm_crop_plan') . '/js/farm_crop_plan_log_status.js');
  $content['form'] = drupal_get_form('farm_crop_plan_form', $entity);
  $content['form']['#access'] = farm_crop_plan_access($entity);
  $content['form']['#weight'] = 100;
}

/**
 * Crop plan form.
 */
function farm_crop_plan_form($form, &$form_state, $plan) {
  $form['#tree'] = TRUE;

  // Store the plan entity for use in submit.
  $form['plan'] = array(
    '#type' => 'value',
    '#value' => $plan,
  );

  // Add Planting fieldset.
  $form['new'] = farm_crop_plan_planting_details_form($plan, NULL, $form_state, array('new'));
  $form['new']['#weight'] = 100;

  // Add Existing Planting fieldset.
  $form['existing'] = array(
    '#type' => 'fieldset',
    '#title' => t('Add Existing Planting'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#weight' => 101,
  );

  $form['existing']['plantings'] = array(
    '#type' => 'textfield',
    '#title' => t('Planting Asset'),
    '#default_value' => '',
    '#autocomplete_path' => 'farm_asset/autocomplete/planting',
  );

  $form['existing']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Add Planting to Plan'),
    '#submit' => array('farm_crop_plan_form_add_planting_submit'),
  );

  // Load information about plantings in this plan.
  $plantings = farm_crop_plan_plantings($plan->id);

  // If there are no plantings, stop here.
  if (empty($plantings)) {
    return $form;
  }

  // Set the mode.
  $mode = 'planting';
  if (!empty($form_state['values']['options']['mode']) &&  $form_state['values']['options']['mode'] == 'area') {
    $mode = 'area';
  }

  // Add an options fieldset.
  $form['options'] = array(
    '#type' => 'fieldset',
    '#title' => t('Display options'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  // Toggle the timeline view by planting (default) or by area.
  $form['options']['mode'] = array(
    '#type' => 'radios',
    '#title' => t('Organize timeline'),
    '#options' => array(
      'planting' => t('by planting'),
      'area' => t('by area'),
    ),
    '#default_value' => 'planting',
    '#ajax' => array(
      'callback' => 'farm_crop_plan_form_timeline_ajax',
      'wrapper' => 'crop-plan-timeline',
    ),
  );

  // Crop plan timeline container.
  $form['timeline'] = array(
    '#type' => 'container',
    '#theme' => 'farm_crop_plan_timeline',
    '#plan' => $plan,
    '#mode' => $mode,
    '#prefix' => '<div id="crop-plan-timeline">',
    '#suffix' => '</div>',
  );

  // Iterate through the plantings and build forms.
  foreach ($plantings as $planting) {

    // If the asset is empty, skip it.
    if (empty($planting['asset'])) {
      continue;
    }

    // Add a planting details form.
    $planting_form = farm_crop_plan_planting_details_form($plan, $planting['asset'], $form_state, array('timeline', 'plantings', $planting['asset']->id));

    // Add the planting to the form values, for use in form submission.
    $planting_form['planting'] = array(
      '#type' => 'value',
      '#value' => $planting['asset'],
    );

    // Add a link to remove the planting.
    $planting_form['remove'] = array(
      '#type' => 'markup',
      '#markup' => l(t('Remove'), 'farm/plan/' . $plan->id . '/farm_crop_plan_planting/' . $planting['asset']->id . '/delete', array('query' => array('destination' => current_path()))),
      '#weight' => 100,
    );

    $form['timeline']['plantings'][$planting['asset']->id] = $planting_form;
  }

  return $form;
}

/**
 * Crop plan form mode ajax callback.
 */
function farm_crop_plan_form_timeline_ajax($form, $form_state) {
  return $form['timeline'];
}

/**
 * Planting details sub-form.
 *
 * @param $plan
 *   The plan entity.
 * @param $planting
 *   The planting entity, if it exists. NULL for a "new planting" form.
 * @param array &$form_state
 *   The $form_state from the parent form. Passed by reference.
 * @param array $parents
 *   An array of parent keys for finding values with
 *   drupal_array_get_nested_value().
 *
 * @return array
 *   Returns a form array for use in the larger crop plan form.
 */
function farm_crop_plan_planting_details_form($plan, $planting, &$form_state, $parents) {

  // Get submitted values from the $form_state['values'] (as well as
  // $form_state['input'] so we can unset values for populating via Ajax).
  $form_values = array();
  if (!empty($form_state['values'])) {
    $form_values = &drupal_array_get_nested_value($form_state['values'], $parents);
  }
  $form_input = array();
  if (!empty($form_state['input'])) {
    $form_input = &drupal_array_get_nested_value($form_state['input'], $parents);
  }

  // Start with a fieldset.
  $form = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  // If this is a new planting, expand the fieldset.
  if (empty($planting)) {
    $form['#collapsed'] = FALSE;
  }

  // Set the fieldset title.
  if (!empty($planting)) {
    $form['#title'] = htmlspecialchars(entity_label('farm_asset', $planting));
  }
  else {
    $form['#title'] = t('Add a planting');
  }

  // If a plan ID is not available, bail.
  if (empty($plan->id)) {
    return $form;
  }

  // Define the date format for logs.
  $date_format = 'Y-m-d';

  // Define form defaults.
  $defaults = array(
    'name' => NULL,
    'crop' => NULL,
    'seeding' => array(
      'log' => NULL,
      'done' => FALSE,
      'date' => NULL,
      'location' => '',
      'quantity' => array(
        'measure' => 'count',
        'value' => NULL,
        'units' => NULL,
      ),
    ),
    'transplanting' => array(
      'log' => NULL,
      'done' => FALSE,
      'days_to_transplant' => '',
      'date' => NULL,
      'location' => '',
      'quantity' => array(
        'measure' => 'count',
        'value' => NULL,
        'units' => NULL,
      ),
    ),
    'days_to_harvest' => '',
    'harvest_window' => '',
  );

  // Load values from the planting and logs to override the defaults.
  if (!empty($planting)) {

    // Get the planting metadata wrapper.
    $planting_wrapper = entity_metadata_wrapper('farm_asset', $planting);

    // Get the planting name.
    $defaults['name'] = $planting->name;

    // Get the crop name.
    $defaults['crop'] = $planting_wrapper->field_farm_crop->label();

    // Load information from the {farm_crop_plan_planting} table.
    $farm_crop_plan_planting = db_query('SELECT * FROM {farm_crop_plan_planting} WHERE plan_id = :plan_id AND asset_id = :asset_id', array(':plan_id' => $plan->id, ':asset_id' => $planting->id))->fetchAssoc();

    // Get the days to transplant.
    $defaults['transplanting']['days_to_transplant'] = $farm_crop_plan_planting['days_to_transplant'];

    // Get the days to harvest.
    $defaults['days_to_harvest'] = $farm_crop_plan_planting['days_to_harvest'];

    // Get the harvest window.
    $defaults['harvest_window'] = $farm_crop_plan_planting['harvest_window'];

    // Define log types to create on planting assets.
    $log_types = array(
      'transplanting' => 'farm_transplanting',
      'seeding' => 'farm_seeding'
    );

    // Iterate through the log types.
    foreach($log_types as $label => $type) {

      // Save the field name to lookup based on the log type.
      $field_name = $label . '_id';

      // Find logs that reference the planting.
      $query = db_select('farm_crop_plan_planting', 'p');
      $query->addField('p', $field_name);
      $query->condition('plan_id', $plan->id);
      $query->condition('asset_id', $planting->id);
      $result = $query->execute();
      foreach ($result as $row) {

        // Check if the log is included in the plan.
        if (!empty($row->{$field_name})) {

          // Load the log.
          $log = log_load($row->{$field_name});

          // Save the log for later.
          $defaults[$label]['log'] = $log;

          // Update default log status.
          $defaults[$label]['done'] = $log->done;

          // Update default form values associated with the log type.
          $defaults[$label]['date'] = $log->timestamp;

          // Load areas referenced by the log.
          $areas = array();
          if (!empty($log->field_farm_movement[LANGUAGE_NONE][0]['value'])) {
            $movement = field_collection_item_load($log->field_farm_movement[LANGUAGE_NONE][0]['value']);
            if (!empty($movement->field_farm_move_to[LANGUAGE_NONE])) {
              foreach ($movement->field_farm_move_to[LANGUAGE_NONE] as $area_ref) {

                // If the term ID is empty, skip it.
                if (empty($area_ref['tid'])) {
                  continue;
                }
                $area_id = $area_ref['tid'];

                // Load the area. If it can't be loaded, skip it.
                $area = taxonomy_term_load($area_id);
                if (empty($area)) {
                  continue;
                }

                // Add to the list of area options.
                $areas[] = entity_label('taxonomy_term', $area);
              }
            }
          }

          // Assemble the location name as a comma-separated list.
          $defaults[$label]['location'] = implode(', ', $areas);

          // Load quantity data from log.
          $data = farm_quantity_log_data($log);
          if (!empty($data[0]['value'])) {
            $quantity = $data[0];
            $defaults[$label]['quantity']['measure'] = $quantity['measure'];
            $defaults[$label]['quantity']['value'] = $quantity['value'];
            $defaults[$label]['quantity']['units'] = $quantity['units'];
          }
        }
      }
    }
  }

  // Save default values for later comparison.
  $form['defaults'] = array(
    '#type' => 'value',
    '#value' => $defaults
  );

  // Get the planting asset ID, or use 0 for new plantings.
  $planting_id = !empty($planting->id) ? $planting->id : 0;

  // Crop.
  $form['crop'] = array(
    '#type' => 'textfield',
    '#title' => t('Crop/variety'),
    '#autocomplete_path' => 'taxonomy/autocomplete/field_farm_crop',
    '#default_value' => $defaults['crop'],
    '#required' => !empty($planting_id),
    '#ajax' => array(
      'callback' => 'farm_crop_plan_form_planting_name_ajax',
      'wrapper' => 'planting-' . $planting_id . '-name',
    ),
    '#weight' => 1,
  );

  // Seeding info.
  $form['seeding'] = array(
    '#type' => 'fieldset',
    '#title' => t('Seeding'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#weight' => 2,
  );

  // Add seeding log to form_state.
  $form['seeding']['log'] = array(
    '#type' => 'value',
    '#value' => $defaults['seeding']['log'],
  );

  // Add a checkbox for status of seeding log.
  $form['seeding']['done'] = array(
    '#type' => 'checkbox',
    '#title' => t('Completed'),
    '#default_value' => $defaults['seeding']['done'],
  );

  // Seeding date.
  // If there are submitted values, convert back to timestamp. Otherwise, use
  // the value from defaults, if available.
  $seeding_date = NULL;
  if (!empty($form_values['seeding']['date'])) {
    $seeding_date = strtotime($form_values['seeding']['date']);
  }
  elseif (!empty($defaults['seeding']['date'])) {
    $seeding_date = $defaults['seeding']['date'];
  }
  $form['seeding']['date'] = array(
    '#type' => 'date_popup',
    '#title' => t('Seeding date'),
    '#date_format' => $date_format,
    '#date_label_position' => 'within',
    '#date_year_range' => '-3:+10',
    '#default_value' => !empty($seeding_date) ? date($date_format, $seeding_date) : NULL,
    '#required' => !empty($defaults['seeding']['log']),
  );

  // Seeding location.
  // Use the submitted value, if available, otherwise use the default value.
  $seeding_location = $defaults['seeding']['location'];
  if (!empty($form_values['seeding']['location'])) {
    $seeding_location = $form_values['seeding']['location'];
  }
  $form['seeding']['location'] = array(
    '#type' => 'textfield',
    '#title' => t( 'Seeding Location'),
    '#autocomplete_path' => 'taxonomy/autocomplete/field_farm_area',
    '#default_value' => $seeding_location,
    '#ajax' => array(
      'callback' => 'farm_crop_plan_form_planting_name_ajax',
      'wrapper' => 'planting-' . $planting_id . '-name',
    ),
  );

  // Transplanting info.
  $form['transplanting'] = array(
    '#type' => 'fieldset',
    '#title' => t('Transplanting'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#weight' => 3,
  );

  // Add transplanting log to form_state.
  $form['transplanting']['log'] = array(
    '#type' => 'value',
    '#value' => $defaults['transplanting']['log'],
  );

  // Add a checkbox for status of transplanting log.
  $form['transplanting']['done'] = array(
    '#type' => 'checkbox',
    '#title' => t('Completed'),
    '#default_value' => $defaults['transplanting']['done'],
  );

  // Days to transplant.
  // If "transplanting date" was changed in the form, calculate the days from
  // seeding to transplanting. Otherwise, use the submitted value, or the value
  // from defaults, if available.
  $days_to_transplant = '';
  if (!empty($form_values['transplanting']['date'])) {
    if (!empty($seeding_date)) {
      $days_to_transplant = round((strtotime($form_values['transplanting']['date']) - $seeding_date) / (60 * 60 * 24));
      unset($form_input['transplanting']['days_to_transplant']);
    }
  }
  elseif (!empty($form_values['transplanting']['days_to_transplant'])) {
    $days_to_transplant = strtotime($form_values['transplanting']['days_to_transplant']);
  }
  elseif (!empty($defaults['transplanting']['days_to_transplant'])) {
    $days_to_transplant = $defaults['transplanting']['days_to_transplant'];
  }
  $form['transplanting']['days_to_transplant'] = array(
    '#type' => 'textfield',
    '#title' => t('Days to Transplant'),
    '#default_value' => $days_to_transplant,
    '#element_validate' => array('element_validate_integer_positive'),
    '#ajax' => array(
      'callback' => 'farm_crop_plan_form_transplant_date_ajax',
      'wrapper' => 'planting-' . $planting_id . '-transplant-date',
    ),
    '#prefix' => '<div id="planting-' . $planting_id . '-transplant-days">',
    '#suffix' => '</div>',
  );

  // Transplanting date.
  // If "days to transplant" was changed in the form, calculate the date based
  // on the seeding date. Otherwise, use the submitted value, or the value from
  // defaults, if available.
  $transplanting_date = NULL;
  if (!empty($form_values['transplanting']['days_to_transplant'])) {
    if (!empty($seeding_date)) {
      $transplanting_date = strtotime('+' . $form_values['transplanting']['days_to_transplant'] . ' days', $seeding_date);
      unset($form_input['transplanting']['date']);
    }
  }
  elseif (!empty($form_values['transplanting']['date'])) {
    $transplanting_date = strtotime($form_values['transplanting']['date']);
  }
  elseif (!empty($defaults['transplanting']['date'])) {
    $transplanting_date = $defaults['transplanting']['date'];
  }
  $form['transplanting']['date'] = array(
    '#type' => 'date_popup',
    '#title' => t('Transplanting date'),
    '#date_format' => $date_format,
    '#date_label_position' => 'within',
    '#date_year_range' => '-3:+10',
    '#default_value' => !empty($transplanting_date) ? date($date_format, $transplanting_date) : NULL,
    '#required' => !empty($defaults['transplanting']['log']),
    '#ajax' => array(
      'callback' => 'farm_crop_plan_form_days_to_transplant_ajax',
      'wrapper' => 'planting-' . $planting_id . '-transplant-days',
    ),
    '#prefix' => '<div id="planting-' . $planting_id . '-transplant-date">',
    '#suffix' => '</div>',
  );

  // Transplanting location.
  // Use the submitted value, if available, otherwise use the default value.
  $transplanting_location = $defaults['transplanting']['location'];
  if (!empty($form_values['transplanting']['location'])) {
    $transplanting_location = $form_values['transplanting']['location'];
  }
  $form['transplanting']['location'] = array(
    '#type' => 'textfield',
    '#title' => t( 'Transplanting Location'),
    '#autocomplete_path' => 'taxonomy/autocomplete/field_farm_area',
    '#default_value' => $transplanting_location,
    '#ajax' => array(
      'callback' => 'farm_crop_plan_form_planting_name_ajax',
      'wrapper' => 'planting-' . $planting_id . '-name',
    ),
  );

  // Save quantity measure options.
  $quantity_measure_options = farm_quantity_measure_options();

  // Add quantity fields for seeding and transplanting logs.
  $quantity_log_types = array('seeding', 'transplanting');
  foreach($quantity_log_types as $type) {
    $form[$type]['quantity'] = array(
      '#type' => 'fieldset',
      '#title' => t('Quantity'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );

    // Quantity measure.
    $form[$type]['quantity']['measure'] = array(
      '#type' => 'select',
      '#title' => t('Measure'),
      '#options' => $quantity_measure_options,
      '#default_value' => $defaults[$type]['quantity']['measure'],
    );

    // Quantity value.
    $form[$type]['quantity']['value'] = array(
      '#type' => 'textfield',
      '#title' => t('Value'),
      '#default_value' => $defaults[$type]['quantity']['value'],
    );

    // Quantity units.
    $form[$type]['quantity']['units'] = array(
      '#type' => 'textfield',
      '#title' => t('Units'),
      '#autocomplete_path' => 'taxonomy/autocomplete/field_farm_quantity_units',
      '#default_value' => $defaults[$type]['quantity']['units'],
    );
  }

  // Transplanting info.
  $form['harvest'] = array(
    '#type' => 'fieldset',
    '#title' => t('Harvest'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#weight' => 4,
  );

  // Days to harvest.
  // If "first harvest date" was changed in the form, calculate the days from
  // seeding/transplanting to harvest. Otherwise, use the submitted value, or
  // the value from defaults, if available.
  $days_to_harvest = '';
  if (!empty($form_values['harvest']['first_harvest_date'])) {
    $start_date = !empty($seeding_date) ? $seeding_date : $transplanting_date;
    if (!empty($start_date)) {
      $days_to_harvest = round((strtotime($form_values['harvest']['first_harvest_date']) - $start_date) / (60 * 60 * 24));
      unset($form_input['harvest']['days_to_harvest']);
    }
  }
  elseif (!empty($form_values['harvest']['days_to_harvest'])) {
    $days_to_harvest = $form_values['harvest']['days_to_harvest'];
  }
  elseif (!empty($defaults['days_to_harvest'])) {
    $days_to_harvest = $defaults['days_to_harvest'];
  }
  $form['harvest']['days_to_harvest'] = array(
    '#type' => 'textfield',
    '#title' => t('Days to harvest'),
    '#default_value' => $days_to_harvest,
    '#element_validate' => array('element_validate_integer_positive'),
    '#ajax' => array(
      'callback' => 'farm_crop_plan_form_harvest_date_ajax',
      'wrapper' => 'planting-' . $planting_id . '-harvest-date',
    ),
    '#prefix' => '<div id="planting-' . $planting_id . '-harvest-days">',
    '#suffix' => '</div>',
  );

  // First harvest date.
  // If "days to harvest" was set in the form, calculate the date based on the
  // seeding/transplanting date. Otherwise, if a submitted value is available,
  // use that. Lastly, if a start date and default days to harvest is set,
  // use them to calculate a harvest date for initial form load (before any
  // values are submitted).
  $harvest_date = NULL;
  $start_date = !empty($seeding_date) ? $seeding_date : $transplanting_date;
  if (!empty($form_values['harvest']['days_to_harvest'])) {
    if (!empty($start_date)) {
      $harvest_date = strtotime('+' . $form_values['harvest']['days_to_harvest'] . ' days', $start_date);
      unset($form_input['harvest']['first_harvest_date']);
    }
  }
  elseif (!empty($form_values['harvest']['first_harvest_date'])) {
    $harvest_date = strtotime($form_values['harvest']['first_harvest_date']);
  }
  elseif (!empty($start_date) && !empty($defaults['days_to_harvest'])) {
    $harvest_date = strtotime('+' . $defaults['days_to_harvest'] . ' days', $start_date);
  }
  $form['harvest']['first_harvest_date'] = array(
    '#type' => 'date_popup',
    '#title' => t('First harvest date'),
    '#date_format' => $date_format,
    '#date_label_position' => 'within',
    '#date_year_range' => '-3:+10',
    '#default_value' => !empty($harvest_date) ? date($date_format, $harvest_date) : NULL,
    '#ajax' => array(
      'callback' => 'farm_crop_plan_form_days_to_harvest_ajax',
      'wrapper' => 'planting-' . $planting_id . '-harvest-days',
    ),
    '#prefix' => '<div id="planting-' . $planting_id . '-harvest-date">',
    '#suffix' => '</div>',
  );

  // Harvest window.
  $form['harvest']['harvest_window'] = array(
    '#type' => 'textfield',
    '#title' => t('Harvest window'),
    '#default_value' => $defaults['harvest_window'],
    '#element_validate' => array('element_validate_integer_positive'),
  );

  // Planting asset name.
  // If the crop/varient, seeding location, or transplanting location values
  // change, generate a new planting asset name. Otherwise, use the default
  // value, if available.
  $planting_name = '';
  if (!empty($form_values['crop'])) {
    $planting_location = '';
    if (!empty($form_values['transplanting']['location'])) {
      $planting_location = $form_values['transplanting']['location'];
    }
    elseif (!empty($form_values['seeding']['location'])) {
      $planting_location = $form_values['seeding']['location'];
    }
    $planting_name = farm_crop_plan_planting_name_generate($plan, $form_values['crop'], $planting_location);
    unset($form_input['name']);
  }
  elseif (!empty($defaults['name'])) {
    $planting_name = $defaults['name'];
  }
  $form['name'] = array(
    '#type' => 'textfield',
    '#title' => t('Planting Name'),
    '#description' => t('The planting asset name will default to "[Season] [Location] [Crop(s)]" but can be modified here. If both a seeding and a transplanting log are created, the transplanting location will be used.' ),
    '#default_value' => $planting_name,
    '#required' => !empty($planting_id),
    '#weight' => 6,
    '#prefix' => '<div id="planting-' . $planting_id . '-name">',
    '#suffix' => '</div>',
  );

  // Submit button.
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
    '#weight' => 100,
  );

  return $form;
}

/**
 * Ajax callback that returns the planting name element.
 */
function farm_crop_plan_form_planting_name_ajax($form, $form_state) {
  return farm_crop_plan_ajax_helper($form, $form_state, 'name');
}

/**
 * Ajax callback that returns a days to transplant element.
 */
function farm_crop_plan_form_days_to_transplant_ajax($form, $form_state) {
  return farm_crop_plan_ajax_helper($form, $form_state, 'days_to_transplant');
}

/**
 * Ajax callback that returns a transplanting date element.
 */
function farm_crop_plan_form_transplant_date_ajax($form, $form_state) {
  return farm_crop_plan_ajax_helper($form, $form_state, 'date');
}

/**
 * Ajax callback that returns a days to harvest element.
 */
function farm_crop_plan_form_days_to_harvest_ajax($form, $form_state) {
  return farm_crop_plan_ajax_helper($form, $form_state, 'days_to_harvest');
}

/**
 * Ajax callback that returns a harvest date element.
 */
function farm_crop_plan_form_harvest_date_ajax($form, $form_state) {
  return farm_crop_plan_ajax_helper($form, $form_state, 'first_harvest_date');
}

/**
 * Helper function for use in Ajax callbacks above.
 */
function farm_crop_plan_ajax_helper($form, $form_state, $name) {
  $parents = $form_state['triggering_element']['#parents'];
  array_pop($parents);
  $value = drupal_array_get_nested_value($form, $parents);
  if (!empty($value[$name])) {
    return $value[$name];
  }

  // If that didn't work, try one more level up. This is used when a field
  // within a nested fieldset needs to update a field in the parent fieldset.
  // For example: transplanting location is used to update planting name.
  else {
    array_pop($parents);
    $value = drupal_array_get_nested_value($form, $parents);
    if (!empty($value[$name])) {
      return $value[$name];
    }
  }
}

/**
 * Planting form validation.
 */
function farm_crop_plan_form_validate($form, &$form_state) {

  // If seeding/transplanting dates were provided for a "new" planting, but the
  // crop/variety is empty, throw an error.
  if ((!empty($form_state['values']['new']['seeding']['date']) || !(empty($form_state['values']['new']['transplanting']['date']))) && empty($form_state['values']['new']['crop'])) {
    form_error($form['new']['crop'], t('The crop/variety must be specified to create a new planting.'));
  }

  // If a "new planting" crop/variety is entered, ensure that a planting name
  // is provided as well.
  if (!empty($form_state['values']['new']['crop']) && empty($form_state['values']['new']['name'])) {
    form_error($form['new']['name'], t('A new planting must have a name.'));
  }

  // If a "new planting" crop/variety is entered, validate the new planting.
  if (!empty($form_state['values']['new']['crop'])) {
    farm_crop_plan_form_validate_planting($form['new'], $form_state['values']['new']);
  }

  // Iterate through the existing plantings and validate each.
  foreach ($form_state['values']['timeline']['plantings'] as $delta => $planting_values) {
    farm_crop_plan_form_validate_planting($form['timeline']['plantings'][$delta], $planting_values);
  }
}

/**
 * Helper function for validating a single planting details form.
 */
function farm_crop_plan_form_validate_planting($form, $values) {

  // Load the planting name, default to 'New Planting'
  // if the planting hasn't been created.
  $planting_name = 'New Planting';
  if (!empty($values['planting'])) {
    $planting_name = $values['planting']->name;
  }

  // Ensure seeding/transplanting date is set if location is provided.
  if (!empty($values['seeding']['location']) && empty($values['seeding']['date'])) {
    form_error($form['seeding']['date'], $planting_name . ': ' . t('Seeding date must be provided with seeding location.'));
  }
  if (!empty($values['transplanting']['location']) && empty($values['transplanting']['date'])) {
    form_error($form['transplanting']['date'], $planting_name . ': ' . t('Transplanting date must be provided with transplanting location.'));
  }

  // If "days to transplant" is provided, there must be a seeding date.
  if (!empty($values['transplanting']['days_to_transplant']) && empty($values['seeding']['date'])) {
    form_error($form['transplanting']['days_to_transplant'], $planting_name . ': ' . t('Seeding date is required to calculate transplanting date from days to transplant.'));
  }

  // If both seeding and transplanting dates are provided, ensure transplanting
  // comes after seeding.
  if (!empty($values['seeding']['date']) && !empty($values['transplanting']['date']) && strtotime($values['seeding']['date']) >= strtotime($values['transplanting']['date'])) {
    form_error($form['transplanting']['date'], $planting_name . ': ' . t('Transplanting date must be after seeding date.'));
  }

  // Ensure days to harvest is supplied with harvest date.
  if (!empty($values['harvest']['first_harvest_date']) && empty($values['harvest']['days_to_harvest'])) {
    form_error($form['harvest']['first_harvest_date'], $planting_name . ': ' . t('Days to harvest must be provided with harvest date.'));
  }
}

/**
 * Planting form submit.
 */
function farm_crop_plan_form_submit(&$form, &$form_state) {

  // Load the plan.
  $plan = $form_state['values']['plan'];
  $plan_wrapper = entity_metadata_wrapper('farm_plan', $plan);

  // Get the season(s) from the plan.
  foreach ($plan_wrapper->field_farm_season as $season_wrapper) {
    $seasons[] = $season_wrapper->label();
  }

  // Array of log types to create.
  $log_types = array(
    'seeding' => 'farm_seeding',
    'transplanting' => 'farm_transplanting',
  );

  // Start an array of plantings.
  $plantings = array();

  // Add the new plantings.
  $plantings[] = array(
    'submitted' => $form_state['values']['new'],
    'current' => $form['new'],
  );

  // Add existing plantings to list for validation.
  if (!empty($form_state['values']['timeline']['plantings'])) {
    foreach ($form_state['values']['timeline']['plantings'] as $planting_id => $planting_values) {
      $plantings[] = array(
        'submitted' => $planting_values,
        'current' => $form['timeline']['plantings'][$planting_id],
      );
    }
  }

  // Iterate through plantings and update or create as necessary.
  foreach($plantings as $planting_info) {

    // Save submitted and old values from form.
    $planting_values = $planting_info['submitted'];
    $current_values = $planting_info['current'];

    // Skip if planting has no values.
    if (empty($planting_values)) {
      continue;
    }

    // Start array of logs to create.
    $new_logs = array();

    // Get the submitted planting name.
    $planting_name = $planting_values['name'];

    // If no name was given, build a planting name.
    if (empty($planting_name)) {

      // The "final" location of the planting is assumed to be the transplanting
      // location. If a transplanting is not being created, but a seeding is, then
      // use the seeding location.
      $location = '';
      if (!empty($planting_values['transplanting']['location'])) {
        $location = $planting_values['transplanting']['location'];
      }
      elseif (!empty($planting_values['seeding']['location'])) {
        $location = $planting_values['seeding']['location'];
      }

      // The planting will be named based on the season(s), location and crop.
      $planting_name_parts = array(
        implode('/', $seasons),
        $location,
        $planting_values['crop'],
      );
      $planting_name = implode(' ', $planting_name_parts);
    }

    // Check if the submitted planting already exists.
    if (!empty($planting_values['planting'])) {

      // Get the planting asset.
      $planting_asset = $planting_values['planting'];

      // Keep track if planting was updated, so we can set a message afterwards.
      $updated_planting = FALSE;

      // Update the planting name if needed.
      // This is done before updating logs so that they will
      // be generated with the correct name.
      if ($planting_asset->name != $planting_name) {

        // Get an entity metadata wrapper for the planting.
        $planting_wrapper = entity_metadata_wrapper('farm_asset', $planting_asset);

        // Update the name.
        $planting_wrapper->name = $planting_name;

        // Save the planting.
        $planting_wrapper->save();

        // Remember the planting was updated.
        $updated_planting = TRUE;
      }

      // If the crop changed, update the planting.
      if ($planting_values['crop'] != $current_values['crop']['#default_value']) {

        // Get an entity metadata wrappers for the planting.
        $planting_wrapper = entity_metadata_wrapper('farm_asset', $planting_asset);

        // Get the crop term (or create a new one), and add it to the planting.
        $crop = farm_term($planting_values['crop'], 'farm_crops');
        $planting_wrapper->field_farm_crop->set(array(NULL));
        $planting_wrapper->field_farm_crop[] = $crop;

        // Save the planting.
        $planting_wrapper->save();

        // Remember that the planting was updated.
        $updated_planting = TRUE;
      }

      // Load values for logs that need to be created.
      foreach ($log_types as $name => $type) {

        // Current values.
        // Save a reference to the rendered form values.
        // These values reflect the current state of logs.
        $current_log_values = $current_values[$name];

        // Save a reference to the existing log.
        $existing_log = $planting_values[$name]['log'];

        // New values.
        $new_date = $planting_values[$name]['date'];
        $new_location = $planting_values[$name]['location'];

        // Skip if date is not provided.
        if (empty($new_date)) {
          continue;
        }

        // Check for existing log.
        if (empty($existing_log)) {

          // Add log info to create later.
          $new_logs[] = array(
            'type' => $type,
            'planting_asset' => $planting_asset,
            'done' => $planting_values[$name]['done'],
            'date' => $new_date,
            'location' => $new_location,
            'quantity' => $planting_values[$name]['quantity'],
          );

          // Skip updating.
          continue;
        }

        // Keep track if the log was updated.
        $updated_log = FALSE;

        // If the Planting crop changed, update the log name.
        if ($updated_planting) {

          // Blank out the log name to auto-regenerate.
          $existing_log->name = '';
          log_save($existing_log);

          // Remember that the log was updated.
          $updated_log = TRUE;
        }

        // Check if the log status changed.
        $old_status = $planting_values['defaults'][$name]['done'];
        $new_status = $planting_values[$name]['done'];
        if ($old_status != $new_status) {

          // Update log.
          $existing_log->done = $new_status;
          log_save($existing_log);
          $updated_log = TRUE;
        }

        // If the log date changed, update the log.
        $old_timestamp = $planting_values['defaults'][$name]['date'];
        $new_timestamp = strtotime($new_date);
        if ($new_timestamp != $old_timestamp) {

          // Update the log timestamp.
          $existing_log->timestamp = $new_timestamp;

          log_save($existing_log);

          // Remember that the log was updated.
          $updated_log = TRUE;
        }

        // If the location changed, update the log.
        $default_location = $planting_values['defaults'][$name]['location'];
        if ($new_location != $default_location) {

          // Load new areas.
          $areas = farm_term_parse_names($new_location, 'farm_areas', TRUE);

          // If the log has a movement associated with it...
          if (!empty($existing_log->field_farm_movement[LANGUAGE_NONE][0]['value'])) {

            // Load the movement information associated with the log.
            $movement = field_collection_item_load($existing_log->field_farm_movement[LANGUAGE_NONE][0]['value']);
            $movement_wrapper = entity_metadata_wrapper('field_collection_item', $movement);
            $movement_wrapper->field_farm_move_to = array();

            // Add areas to movement.
            foreach ($areas as $area) {
              $area = taxonomy_term_load($area->tid);
              $movement_wrapper->field_farm_move_to[] = $area;
            }
            $movement_wrapper->save();
          }

          // Or, if the log does not have a movement associated with it...
          else {

            // Add a new movement to the log.
            $movement = entity_create('field_collection_item', array('field_name' => 'field_farm_movement'));
            $movement->setHostEntity('log', $existing_log);

            // Create an entity wrapper for the adjustment.
            $movement_wrapper = entity_metadata_wrapper('field_collection_item', $movement);

            // Iterate through the areas and add each to the "Move to" field.
            foreach ($areas as $area) {
              $movement_wrapper->field_farm_move_to[] = $area;
            }

            // Save the movement.
            $movement_wrapper->save();
          }

          // Remember that the log was updated.
          $updated_log = TRUE;
        }

        // Check if the log quantity changed.
        // Create array of values to compare.
        $current_quantity_values = array(
          'measure' => $current_log_values['quantity']['measure']['#default_value'],
          'value' => $current_log_values['quantity']['value']['#default_value'],
          'units' => $current_log_values['quantity']['units']['#default_value'],
        );
        $new_quantity_values = $planting_values[$name]['quantity'];
        $quantity_changed = $current_quantity_values != $new_quantity_values;

        // Update log quantities.
        if ($quantity_changed) {

          // Load the log entity metadata wrapper.
          $log_wrapper = entity_metadata_wrapper('log', $existing_log);

          // Check if submitted quantity has a value.
          // Quantities are only saved if a value is included.
          $has_quantity = !(empty($planting_values[$name]['quantity']['value']));

          // Build new quantity measurements.
          $measurements = array();
          if ($has_quantity) {
            $measurements[] = $planting_values[$name]['quantity'];
          }

          // Check for existing quantity.
          if (isset($log_wrapper->field_farm_quantity[0])) {

            // Get the first quantity.
            $quantity_wrapper = $log_wrapper->field_farm_quantity[0];

            // Update existing quantity.
            if ($has_quantity) {
              // Get the measurement.
              $measurement = $measurements[0];

              // Set the quantity measure, if available.
              if (!empty($measurement['measure'])) {
                $quantity_wrapper->field_farm_quantity_measure->set($measurement['measure']);
              }

              // Set the quantity value, if available.
              if (!empty($measurement['value'])) {

                // Clear the old value.
                $quantity_wrapper->field_farm_quantity_value = array();

                $value_fraction = fraction_from_decimal($measurement['value']);
                $quantity_wrapper->field_farm_quantity_value->numerator->set($value_fraction->getNumerator());
                $quantity_wrapper->field_farm_quantity_value->denominator->set($value_fraction->getDenominator());
              }

              // Set the units, if available.
              if (!empty($measurement['units'])) {

                // Load/create units term.
                $units_term = farm_term($measurement['units'], 'farm_quantity_units');

                // Set the quantity units.
                $quantity_wrapper->field_farm_quantity_units = $units_term;
              }

              // Save the quantity.
              $quantity_wrapper->save();
            }
            // Remove the first quantity.
            else {
              entity_delete('field_collection_item', $quantity_wrapper->item_id->value());
              unset($existing_log->field_farm_quantity[LANGUAGE_NONE][0]);
            }
          }
          // No quantities exist, create a new one.
          else if ($has_quantity) {

            // If there are quantity measurements, add them to the log.
            if (!empty($measurements)) {
              farm_quantity_log_add_measurements($existing_log, $measurements);
            }
          }

          // Save the log and remember that we updated it.
          log_save($existing_log);
          $updated_log = TRUE;
        }

        // If the log was updated, display a message.
        if ($updated_log) {
          $log_name = entity_label('log', $existing_log);
          $log_uri = entity_uri('log', $existing_log);
          $log_url = url($log_uri['path']);
          drupal_set_message(
            t('The @log_type log <a href="!log_url">@log_name</a> was updated.',
              array('@log_type' => $name, '!log_url' => $log_url, '@log_name' => $log_name))
          );
        }
      }

      // If the planting was updated, display a message.
      if ($updated_planting) {
        $planting_name = entity_label('farm_asset', $planting_asset);
        $planting_uri = entity_uri('farm_asset', $planting_asset);
        $planting_url = url($planting_uri['path']);
        drupal_set_message(
          t('The planting asset <a href="!planting_url">@planting_name</a> was updated.',
          array('!planting_url' => $planting_url, '@planting_name' => $planting_name))
        );
      }
    }

    // Create new planting if one doesn't exist.
    if (empty($planting_values['planting'])) {

      // Bail if no crop was provided.
      // The prevents creating new plantings when the form is empty.
      if (empty($planting_values['crop'])) {
        continue;
      }

      // Get the crop name that was entered and create/load it's term.
      $crop_term = farm_term($planting_values['crop'], 'farm_crops');

      // Create a new planting asset.
      $values = array(
        'type' => 'planting',
        'name' => $planting_name,
      );
      $planting_asset = entity_create('farm_asset', $values);
      $planting_wrapper = entity_metadata_wrapper('farm_asset', $planting_asset);

      // Add the season(s).
      foreach ($plan_wrapper->field_farm_season as $season_wrapper) {
        $planting_wrapper->field_farm_season[] = $season_wrapper;
      }

      // Add the crop.
      $planting_wrapper->field_farm_crop[] = $crop_term;

      // Save the planting.
      $planting_wrapper->save();

      // Link the asset to this crop plan.
      farm_plan_link_record('farm_crop_plan_planting', $plan->id, $planting_asset->id);

      // Set a message.
      $planting_name = entity_label('farm_asset', $planting_asset);
      $planting_uri = entity_uri('farm_asset', $planting_asset);
      $planting_url = url($planting_uri['path']);
      drupal_set_message(
        t('Planting created: <a href="!planting_url">@planting_name</a>',
          array('!planting_url' => $planting_url, '@planting_name' => $planting_name))
      );

      // Load values for logs that need to be created.
      foreach ($log_types as $name => $type) {
        $date = $planting_values[$name]['date'];
        $location = $planting_values[$name]['location'];
        if (!empty($date)) {
          $new_logs[] = array(
            'type' => $type,
            'planting_asset' => $planting_asset,
            'done' => $planting_values[$name]['done'],
            'date' => $date,
            'location' => $location,
            'quantity' => $planting_values[$name]['quantity'],
          );
        }
      }
    }

    // Iterate through the logs.
    foreach ($new_logs as $log_values) {

      // If no details were provided, skip it.
      if (empty($log_values)) {
        continue;
      }

      // Skip if no planting asset is provided.
      if (empty($log_values['planting_asset'])) {
        continue;
      }

      // Get the log type.
      $type = $log_values['type'];

      // Save the log values.
      $planting_asset = $log_values['planting_asset'];

      // Convert the date to a timestamp.
      $timestamp = strtotime($log_values['date']);

      // If the location is available, load areas.
      $areas = array();
      if (!empty($log_values['location'])) {
        $areas = farm_term_parse_names($log_values['location'], 'farm_areas', TRUE);
      }

      // Save the log status.
      $done = $log_values['done'];

      // If there is a location, create a movement log.
      if (!empty($log_values['location'])) {
        $log = farm_movement_create($planting_asset, $areas, $timestamp, $type, $done);
      }

      // Otherwise, create a normal log (without movement location).
      else {
        $log = farm_log_create($type, '', $timestamp, $done, array($planting_asset));
      }

      // Build quantity measurements.
      $measurements = array();
      if (!empty($log_values['quantity']['value'])) {
        $measurements[] = $log_values['quantity'];
      }

      // If there are quantity measurements, add them to the log.
      if (!empty($measurements)) {
        farm_quantity_log_add_measurements($log, $measurements);
      }

      // Create an entity metadata wrapper for the log.
      $log_wrapper = entity_metadata_wrapper('log', $log);

      // Save the log.
      $log_wrapper->save();

      // Link the log to the crop plan.
      if ($type == 'farm_seeding') {
        $relationship = 'farm_crop_plan_seeding';
      }
      elseif ($type == 'farm_transplanting') {
        $relationship = 'farm_crop_plan_transplanting';
      }
      farm_plan_link_record($relationship, $plan->id, $log->id, array('asset_id' => $planting_asset->id));
    }

    // Build array of crop plan planting attributes to update.
    $record = array(
      'plan_id' => $plan->id,
      'asset_id' => $planting_asset->id,
    );

    // Update days_to_transplant.
    if (!empty($planting_values['transplanting']['days_to_transplant'])) {
      $record['days_to_transplant'] = $planting_values['transplanting']['days_to_transplant'];
    }

    // Update days_to_harvest. Replace empty string with NULL.
    $days_to_harvest = $planting_values['harvest']['days_to_harvest'];
    if (empty($days_to_harvest)) {
      $days_to_harvest = NULL;
    }
    $record['days_to_harvest'] = $days_to_harvest;

    // Update harvest_window. Replace empty string with NULL.
    $harvest_window = $planting_values['harvest']['harvest_window'];
    if (empty($harvest_window)) {
      $harvest_window = NULL;
    }
    $record['harvest_window'] = $harvest_window;

    // Update the Crop Plan Planting.
    drupal_write_record('farm_crop_plan_planting', $record, array('plan_id', 'asset_id'));
  }
}

/*
 * Submit callback to add an existing planting to a crop plan.
 */
function farm_crop_plan_form_add_planting_submit($form, $form_state) {

  // Validate planting asset(s).
  // Extract asset IDs and load assets.
  $assets = array();
  $asset_names = drupal_explode_tags($form_state['values']['existing']['plantings']);
  foreach($asset_names as $asset_name) {
    $id = 0;
    $matches = array();
    $result = preg_match('/\\[id: ([0-9]+)\\]/', $asset_name, $matches);
    if (!empty($matches[$result])) {
      $id = $matches[$result];
    }

    // If an ID couldn't be extracted, throw an error.
    if (empty($id)) {
      form_set_error('existing][plantings', t('Could not load the planting asset. Make sure the planting asset ID is included. For example: "My planting [id: 123]"'));
    }

    // Load the asset.
    $asset = farm_asset_load($id);

    // If asset was loaded add to list of assets.
    if (!empty($asset)) {
      $assets[$id] = $asset;
    }

    // If the asset didn't load, throw an error.
    if (empty($asset)) {
      form_set_error('existing][plantings', t('Could not load the planting asset. Make sure the planting name and ID are correct.'));
    }
  }

  // If assets were found.
  if (!empty($assets)) {

    // Load the plan.
    $plan = $form_state['values']['plan'];

    // Add each planting to the plan.
    farm_crop_plan_add_planting($plan, $assets);
  }
}

/**
 * Generate a planting name for a given plan, crop, and location.
 *
 * @param $plan
 *   The plan entity that the planting is associated with.
 * @param string $crop
 *   The crop/variety of the planting.
 * @param string $location
 *   The location of the planting. This is optional.
 *
 * @return string
 *   Returns a name for the planting.
 */
function farm_crop_plan_planting_name_generate($plan, $crop, $location = '') {

  // Start an array of name parts.
  $parts = array();

  // Get the plan wrapper.
  $plan_wrapper = entity_metadata_wrapper('farm_plan', $plan);

  // Get the season(s) from the plan.
  foreach ($plan_wrapper->field_farm_season as $season_wrapper) {
    $seasons[] = $season_wrapper->label();
  }

  // Concatenate the seasons together, separated by slashes.
  $season = implode('/', $seasons);
  if (!empty($season)) {
    $parts[] = $season;
  }

  // Add the location, if available.
  if (!empty($location)) {
    $parts[] = $location;
  }

  // Add the crop/variety.
  $parts[] = $crop;

  // Assemble and return the planting name.
  return implode(' ', $parts);
}

/**
 * Collect information about plantings in a plan.
 *
 * @param $plan_id
 *   The ID of the plan.
 *
 * @return array
 *   Returns an array of planting information.
 */
function farm_crop_plan_plantings($plan_id) {

  // Loading planting info can be heavy, so static cache the results.
  $plantings = &drupal_static(__FUNCTION__);
  if (isset($plantings)) {
    return $plantings;
  }

  // Start with an empty array.
  $plantings = array();

  // Load records from the {farm_crop_plan_planting} table.
  $planting_records = db_query('SELECT * FROM {farm_crop_plan_planting} WHERE plan_id = :plan_id', array(':plan_id' => $plan_id))->fetchAll();

  // If there are no planting records, bail.
  if (empty($planting_records)) {
    return $plantings;
  }

  // Iterate through the planting records to collect the information we need.
  foreach ($planting_records as $planting_record) {

    // Start an array of planting info with empty data.
    $planting_info = array(
      'asset' => NULL,
      'days_to_harvest' => NULL,
      'harvest_window' => NULL,
      'seeding' => NULL,
      'transplanting' => NULL,
      'stages' => array(),
    );

    // Load the planting asset.
    $planting_asset = farm_asset_load($planting_record->asset_id);
    if (!empty($planting_asset)) {
      $planting_info['asset'] = $planting_asset;
    }

    // Load "days to harvest", if available.
    if (!empty($planting_record->days_to_harvest)) {
      $planting_info['days_to_harvest'] = $planting_record->days_to_harvest;
    }

    // Load "harvest window".
    if (!empty($planting_record->harvest_window)) {
      $planting_info['harvest_window'] = $planting_record->harvest_window;
    }

    // If there is a seeding log, load it.
    if (!empty($planting_record->seeding_id)) {
      $planting_info['seeding'] = log_load($planting_record->seeding_id);
    }

    // If there is a transplanting log, load it.
    if (!empty($planting_record->transplanting_id)) {
      $planting_info['transplanting'] = log_load($planting_record->transplanting_id);
    }

    // If "days to harvest" is set , and either a seeding or transplanting log
    // exists, calculate the harvest start and end dates. This will be
    // calculated from the seeding date if it available. Otherwise, the
    // transplanting date will be used.
    $harvest_start = NULL;
    if (!empty($planting_info['days_to_harvest'])) {
      if (!empty($planting_info['seeding']->timestamp)) {
        $harvest_start = strtotime('+' . $planting_info['days_to_harvest'] . ' days', $planting_info['seeding']->timestamp);
      }
      elseif (!empty($planting_info['transplanting']->timestamp)) {
        $harvest_start = strtotime('+' . $planting_info['days_to_harvest'] . ' days', $planting_info['transplanting']->timestamp);
      }
    }

    // If the harvest start date and harvest window are available, calculate the
    // harvest end date.
    $harvest_end = NULL;
    if (!empty($harvest_start) && !empty($planting_info['harvest_window'])) {
      $harvest_end = strtotime('+' . $planting_info['harvest_window'] . ' days', $harvest_start);
    }

    // Add a seeding stage.
    if (!empty($planting_info['seeding'])) {

      // Determine the timestamp when the planting will leave this area.
      // This will either be the transplanting timestamp (if a transplant
      // log exists), or the harvest timestamp.
      $end = $harvest_start;
      if (!empty($planting_info['transplanting']->timestamp)) {
        $end = $planting_info['transplanting']->timestamp;
      }

      $seeding_areas = farm_crop_plan_movement_log_area_ids($planting_info['seeding']);
      $planting_info['stages'][] = array(
        'start' => $planting_info['seeding']->timestamp,
        'end' => $end,
        'type' => 'seeding',
        'areas' => $seeding_areas,
      );
    }

    // Add a transplanting stage.
    if (!empty($planting_info['transplanting'])) {
      $transplanting_areas = farm_crop_plan_movement_log_area_ids($planting_info['transplanting']);
      $planting_info['stages'][] = array(
        'start' => $planting_info['transplanting']->timestamp,
        'end' => $harvest_start,
        'type' => 'transplanting',
        'areas' => $transplanting_areas,
      );
    }

    // Add a harvest stage.
    // The harvest will take place in the transplant area, if it exists.
    // Otherwise it will take place in the seeding area.
    $harvest_areas = !empty($transplanting_areas) ? $transplanting_areas : $seeding_areas;
    if (!empty($planting_record->harvest_window)) {
      $planting_info['stages'][] = array(
        'start' => $harvest_start,
        'end' => $harvest_end,
        'type' => 'harvest',
        'areas' => $harvest_areas,
      );
    }

    // Add planting info to plantings array.
    $plantings[$planting_asset->id] = $planting_info;
  }

  return $plantings;
}

/**
 * Get area IDs associated with a movement log.
 *
 * @param $log
 *   A log entity.
 *
 * @return array
 *   An array of area IDs.
 */
function farm_crop_plan_movement_log_area_ids($log) {
  $area_ids = array();
  if (!empty($log->field_farm_movement[LANGUAGE_NONE][0]['value'])) {
    $movement = field_collection_item_load($log->field_farm_movement[LANGUAGE_NONE][0]['value']);
    if (!empty($movement->field_farm_move_to[LANGUAGE_NONE])) {
      foreach ($movement->field_farm_move_to[LANGUAGE_NONE] as $area_ref) {
        if (empty($area_ref['tid'])) {
          continue;
        }
        $area_ids[] = $area_ref['tid'];
      }
    }
  }
  return $area_ids;
}

/**
 * Build an array of area links from a movement log.
 *
 * @param $log
 *   A log entity.
 *
 * @return array
 *   An array of links to areas, keyed by area ID.
 */
function farm_crop_plan_movement_log_area_links($log) {
  $area_ids = farm_crop_plan_movement_log_area_ids($log);
  $area_links = array();
  foreach ($area_ids as $area_id) {
    $area = taxonomy_term_load($area_id);
    $entity_label = htmlspecialchars(entity_label('taxonomy_term', $area));
    $entity_uri = entity_uri('taxonomy_term', $area);
    $area_link = l($entity_label, $entity_uri['path']);
    $area_links[$area_id] = $area_link;
  }
  return $area_links;
}

/**
 * Add planting(s) to a crop plan.
 *
 * @param $plan
 *    The plan entity to associate planting with.
 * @param array|FarmAsset $plantings
 *    Planting asset(s) to add to plan.
 */
function farm_crop_plan_add_planting($plan, $plantings) {

  // Bail if not a crop plan.
  if ($plan->type != 'crop') {
    return;
  }

  // Convert single planting to array.
  if (!is_array($plantings)) {
    $plantings = array($plantings);
  }

  // Load planting ids already associated with any crop plan.
  $plan_plantings = db_query('SELECT asset_id FROM {farm_crop_plan_planting}')->fetchCol();

  // Loop though assets.
  foreach($plantings as $planting) {

    // Bail if asset is not a planting.
    if ($planting->type != 'planting') {
      continue;
    }

    // Save values for messages to users.
    $planting_name = entity_label('farm_asset', $planting);
    $planting_uri = entity_uri('farm_asset', $planting);
    $planting_url = url($planting_uri['path']);

    // Bail if planting is already associated with a crop plan.
    if (in_array($planting->id, $plan_plantings)) {
      drupal_set_message(
        t('Planting asset <a href="@planting_url">@planting_name</a> is already associated with a crop plan.',
          array('@planting_url' => $planting_url, '@planting_name' => $planting_name)),
        'error'
      );
      continue;
    }

    // Link the asset to this crop plan.
    farm_plan_link_record('farm_crop_plan_planting', $plan->id, $planting->id);

    // Notify the planting was added.
    drupal_set_message(
      t('Planting <a href="@planting_url">@planting_name</a> was added to the crop plan. Set the "days to harvest" in order to see it on the timeline.',
        array('@planting_url' => $planting_url, '@planting_name' => $planting_name))
    );

    // Query for the LAST seeding log associated with the planting.
    $query = farm_log_asset_query($planting->id, 0, NULL, 'farm_seeding', TRUE);
    $query->addField('ss_log', 'id');
    $query->orderBy('ss_log.timestamp', 'ASC');
    $result = $query->execute();

    // If seeding log was found.
    $seeding_log = NULL;
    $seeding_id = $result->fetchField();
    if (!empty($seeding_id)) {

      // Link seeding log to the plan.
      farm_plan_link_record('farm_crop_plan_seeding', $plan->id, $seeding_id, array('asset_id' => $planting->id));

      // Load seeding log for later.
      $seeding_log = log_load($seeding_id);
    }

    // Query for the LAST transplanting log associated with the planting.
    $query = farm_log_asset_query($planting->id, 0, NULL, 'farm_transplanting', TRUE);
    $query->addField('ss_log', 'id');
    $query->orderBy('ss_log.timestamp', 'ASC');

    // Only load transplanting logs occurring after the seeding.
    if (!empty($seeding_log)) {
      $query->where('ss_log.timestamp >= ' . $seeding_log->timestamp);
    }
    $result = $query->execute();

    // If transplanting log was found.
    $transplanting_log = NULL;
    $transplanting_id = $result->fetchField();
    if (!empty($transplanting_id)) {

      // Link transplanting log to the plan.
      farm_plan_link_record('farm_crop_plan_transplanting', $plan->id, $transplanting_id, array('asset_id' => $planting->id));

      // Load transplanting log for later.
      $transplanting_log = log_load($transplanting_id);
    }

    // Build array of crop plan planting attributes to update.
    $record = array(
      'plan_id' => $plan->id,
      'asset_id' => $planting->id,
    );

    // Update days to transplant if known.
    if (!empty($transplanting_log) && !(empty($seeding_log))) {

      // Calculate difference between the log timestamps.
      $days_to_transplant = round(($transplanting_log->timestamp - $seeding_log->timestamp) / (60 * 60 * 24));

      // Add to record array.
      $record['days_to_transplant'] = $days_to_transplant;
    }

    // Update the Crop Plan Planting.
    drupal_write_record('farm_crop_plan_planting', $record, array('plan_id', 'asset_id'));
  }
}
